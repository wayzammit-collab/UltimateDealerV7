<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <meta name="apple-mobile-web-app-title" content="Ultimate Dealer"> 
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#121212"> 

    <meta name="application-name" content="Ultimate Dealer">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚ô†Ô∏è</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22 style=%22background:black%22><text y=%22.9em%22 x=%225%22 font-size=%2290%22>‚ô†Ô∏è</text></svg>">

    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiVWx0aW1hdGUgRGVhbGVyIiwic2hvcnRfbmFtZSI6IkRlYWxlciIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwidGhlbWVfY29sb3IiOiIjMTIxMjEyIiwiYmFja2dyb3VuZF9jb2xvciI6IiMxMjEyMTIifQ==">
    <title>Ultimate Dealer V1</title>
    <style>
        :root {
            --bg-color: #121212;
            --table-color: #1e3a28;
            --text-color: #e0e0e0;
            --accent-green: #2ecc71;
            --accent-red: #e74c3c;
            --accent-gold: #f1c40f;
            --accent-blue: #3498db;
			/* --- NEW SIDE POT COLORS --- */
            --pot-color-main: #2ecc71; /* Green for Main */
            --pot-color-side-1: #3498db; /* Blue for Side 1 */
            --pot-color-side-2: #f1c40f; /* Gold for Side 2 */
            --pot-color-side-3: #9b59b6; /* Purple for Side 3 */
            --pot-color-side-4: #e74c3c; /* Red for Side 4 */
            /* ... existing variables ... */
            --card-width: 28px;
            --card-height: 40px;
			--replay-card-scale: 0.75;
        }

        * { box-sizing: border-box; touch-action: manipulation; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            height: 100dvh; 
            display: flex;
            flex-direction: column;
            overflow: hidden;
            -webkit-user-select: none; user-select: none;
        }

        /* --- VIEWS --- */
        .view { display: none; height: 100%; flex-direction: column; }
        .view.active { display: flex; }

        /* --- SETUP --- */
        .setup-container { padding: 20px; overflow-y: auto; max-width: 600px; margin: 0 auto; width: 100%; }
        h1 { text-align: center; color: var(--accent-gold); margin: 10px 0; font-size: 24px; }
        .form-group { margin-bottom: 15px; background: #1e1e1e; padding: 15px; border-radius: 10px; border: 1px solid #333; }
        label { display: block; margin-bottom: 5px; font-size: 12px; color: #888; font-weight: bold; }
        input, select { width: 100%; padding: 12px; border-radius: 8px; border: 1px solid #444; background: #222; color: #fff; font-size: 16px; outline: none; margin-bottom: 5px; }
        .btn-primary { width: 100%; padding: 15px; background: var(--accent-gold); color: #000; font-weight: bold; border: none; border-radius: 8px; font-size: 18px; margin-top: 10px; cursor: pointer; }

        /* --- HEADER --- */
        header {
            background: #1a1a1a; padding: 5px 10px; padding-top: env(safe-area-inset-top); 
            display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #333; min-height: 60px;
        }
        .street-btn { background: #333; border: 1px solid #555; color: #fff; padding: 4px 10px; border-radius: 4px; font-size: 12px; font-weight: bold; cursor: pointer; }
        .pot-display { font-size: 22px; font-weight: bold; color: var(--accent-green); }
        .header-right { display: flex; gap: 5px; align-items: center; }
        .clock-btn, .pause-btn { background: #333; color: #aaa; border: 1px solid #555; padding: 4px 8px; border-radius: 4px; font-size: 12px; cursor: pointer; }
        .clock-btn.active { border-color: var(--accent-red); color: var(--accent-red); }

        /* --- TABLE --- */
        .table-area {
            flex: 1; background: var(--table-color); position: relative; overflow-y: auto; padding: 10px; 
            display: grid; grid-template-columns: 1fr 1fr; gap: 8px; align-content: start; min-height: 0; 
        }

        .player-card { background: rgba(0,0,0,0.6); border-radius: 8px; padding: 10px; position: relative; border: 2px solid transparent; min-height: 90px; transition: border-color 0.2s; }
        .player-card.active-turn { border-color: var(--accent-gold); background: rgba(50,50,50,0.9); box-shadow: 0 0 12px rgba(241, 196, 15, 0.4); }
        .player-card.folded { opacity: 0.5; filter: grayscale(1); }
        .player-card.sitting-out { opacity: 0.3; border: 1px dashed #777; }
        .player-card.on-break { opacity: 0.4; filter: grayscale(1); border: 1px dashed #555; background: #111; }
        .break-badge { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #333; color: #fff; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: bold; z-index: 10; border: 1px solid #555; }
        .player-card.winner-anim { border-color: var(--accent-green); box-shadow: 0 0 15px var(--accent-green); }
        .player-card.manual-select { border-color: var(--accent-blue); background: rgba(52, 152, 219, 0.2); }
        
        .nit-container { position: absolute; top: 5px; right: 5px; display: flex; gap: 4px; z-index: 20; }
        .nit-chip { width: 30px; height: 30px; background: #fff; border: 3px dashed #c0392b; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: #c0392b; font-weight: 900; font-size: 9px; box-shadow: 0 2px 5px rgba(0,0,0,0.5); flex-shrink: 0; }
        
        .role-btn { position: absolute; width: 22px; height: 22px; border-radius: 50%; font-size: 10px; display: flex; align-items: center; justify-content: center; font-weight: bold; box-shadow: 0 2px 3px rgba(0,0,0,0.5); z-index: 5; }
        .dealer-btn { top: -8px; left: -8px; background: white; color: black; border: 1px solid #ccc; }
        .sb-btn { top: 18px; left: -8px; background: #8e44ad; color: white; border: 1px solid #fff; }
        .bb-btn { top: 44px; left: -8px; background: #222; color: white; border: 1px solid #fff; }

        .p-name { font-weight: bold; font-size: 15px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-right: 30px; margin-left: 10px; }
        .p-stack { color: var(--accent-green); font-family: monospace; font-size: 15px; margin-top: 2px; margin-left: 10px; }
        .p-action { font-size: 13px; color: var(--accent-gold); min-height: 20px; display:flex; align-items:center; margin-top: 2px; font-weight: bold; text-transform: uppercase; letter-spacing: 0.5px; margin-left: 10px; }
        .p-timer { font-size: 11px; color: #888; font-family: monospace; position: absolute; bottom: 8px; right: 8px; }
        .active-turn .p-timer { color: var(--accent-gold); font-weight: bold; }
        .p-cards { display: flex; gap: 4px; margin-top: 6px; min-height: 30px; margin-left: 5px; }
        
        /* CARDS */
        .card-visual { background: white; color: black; border-radius: 4px; width: var(--card-width); height: var(--card-height); display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; box-shadow: 1px 1px 3px rgba(0,0,0,0.5); border: 1px solid #ccc; }
        .card-visual.red { color: #d00; } .card-visual.blue { color: #0088cc; } .card-visual.green { color: #009900; }
        .card-visual.small { width: 14px; height: 18px; font-size: 10px; border-radius: 2px; }
        .card-visual.back { background: #333; border: 2px solid #555; color: transparent; background-image: linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%, #222), linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%, #222); background-size: 10px 10px; background-position: 0 0, 5px 5px; }

        /* CONTROLS */
        .controls { background: #1a1a1a; padding: 8px; border-top: 1px solid #333; display: flex; flex-direction: column; gap: 6px; padding-bottom: calc(8px + env(safe-area-inset-bottom)); }
        .control-row { display: grid; gap: 6px; }
        .row-1 { grid-template-columns: repeat(4, 1fr); }
        .row-2 { grid-template-columns: repeat(5, 1fr); }
        .btn { padding: 14px 2px; border: none; border-radius: 6px; font-weight: bold; font-size: 12px; color: white; cursor: pointer; text-align: center; }
        .btn-bet { background: var(--accent-blue); } .btn-call { background: #27ae60; } .btn-fold { background: var(--accent-red); } .btn-win { background: var(--accent-green); }
        .btn-straddle { background: #8e44ad; } .btn-next { background: var(--accent-gold); color: black; border: 2px solid #f39c12; } .btn-manage { background: #e67e22; } .btn-undo { background: #9b59b6; } 
        .btn-card { background: #555; }
        .btn-rimt { background: #34495e; border: 1px solid #555; }
        .btn-showdown { background: var(--accent-red) !important; color: white !important; border-color: white !important; animation: pulse 2s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.8; } 100% { opacity: 1; } }

        /* BOARD AREA IMPROVEMENTS */
        #board-area {
            background: #111; padding: 10px; display: flex; flex-direction: column; 
            justify-content: center; align-items: center; min-height: 70px; 
            position: relative; border-bottom: 1px solid #333; gap: 8px;
        }
        .board-cards-container { display: flex; gap: 5px; justify-content: center; align-items: center; margin-top: 5px; }
        .runout-container { display: flex; flex-direction: column; align-items: center; width: 100%; }
        .runout-label { font-size: 10px; color: #888; margin-bottom: 2px; }

        .rimt-nav { display: flex; align-items: center; gap: 10px; font-size: 12px; color: #888; margin-bottom: 2px; background: #222; padding: 2px 10px; border-radius: 10px; border: 1px solid #444; }
        .rimt-nav button { background: none; border: none; color: white; font-size: 16px; cursor: pointer; padding: 0 5px; }
        .rimt-nav span { font-weight: bold; color: var(--accent-blue); }

        /* MODALS */
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 2000; justify-content: center; align-items: center; }
        .modal.open { display: flex; }
        .modal-content { background: #222; padding: 20px; border-radius: 12px; width: 95%; max-width: 800px; max-height: 90vh; overflow-y: auto; display: flex; flex-direction: column; }
        .manage-row { background: #333; padding: 10px; margin-bottom: 8px; border-radius: 6px; display: flex; flex-direction: column; gap: 8px; }
        .manage-input { width: 100%; background: #222; border: 1px solid #555; color: white; padding: 8px; border-radius: 4px; font-size: 14px; }
        .manage-controls { display: flex; gap: 5px; justify-content: space-between; }
        .btn-nit-toggle { filter: grayscale(1); opacity: 0.6; } .btn-nit-toggle.active { filter: none; opacity: 1; background: #fff; border: 2px solid var(--accent-red); }
        .btn-break-toggle { background: #444; color: #fff; font-size: 14px; } 
        .btn-break-toggle.active { background: var(--accent-blue); border: 1px solid white; }
        .btn-break-toggle.sitting-out { background: #777; border: 1px dashed #aaa; color: #ccc; }
        
        .btn-kick { background: var(--accent-red) !important; flex: 0.5 !important; }
        .btn-rebuy { background: var(--accent-green); color: black; font-weight: bold; flex: 1.5; }
        .btn-edit-stack { background: #555; border: 1px solid #777; color: white; border-radius: 4px; cursor: pointer; padding: 2px 6px; margin-left: 5px; font-size: 10px; }

        /* Bust Modal Styles */
        .bust-row { background: #2c0b0b; padding: 10px; margin-bottom: 8px; border-radius: 6px; border: 1px solid var(--accent-red); }
        .bust-name { font-weight: bold; color: white; margin-bottom: 5px; display: block; }
        .bust-actions { display: flex; gap: 5px; align-items: center; }
        .bust-input { background: #111; border: 1px solid #555; color: white; padding: 10px; width: 80px; text-align: center; border-radius: 4px; font-weight: bold; margin-right: 5px; }

		/* --- SETTLEMENT MODAL CSS --- */

/* 1. The Background Overlay (Hidden by default) */
#settlement-modal {
    position: fixed;      /* Stay in place when scrolling */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9); /* Dark semi-transparent background */
    z-index: 9999;        /* Sit on top of EVERYTHING */
    display: none;        /* HIDE IT BY DEFAULT! */
    justify-content: center;
    align-items: center;
    backdrop-filter: blur(5px); /* Optional: Nice blur effect */
}

/* 2. The Active State (This makes it appear) */
#settlement-modal.active {
    display: flex !important;
}

/* 3. The Box Itself */
#settlement-modal .modal-content {
    background: #1e1e1e;
    padding: 20px;
    border-radius: 12px;
    border: 1px solid #444;
    box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    width: 95%;
    max-width: 800px;
    max-height: 90vh; /* Allow scrolling if list is long */
    overflow-y: auto;
    animation: popIn 0.3s ease;
}

/* Animation to make it pop */
@keyframes popIn {
    from { transform: scale(0.9); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
}

        /* CONTEXT MENU */
        #context-menu {
            display: none; position: fixed; background: #222; border: 1px solid #444; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.8); z-index: 5000; overflow: hidden; min-width: 150px;
        }
        #context-menu.open { display: block; animation: fadeIn 0.1s ease-out; }
        .ctx-item { padding: 12px 16px; color: #fff; font-size: 14px; border-bottom: 1px solid #333; cursor: pointer; }
        .ctx-item:last-child { border-bottom: none; }
        .ctx-item:active { background: #333; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }

        /* STATS & HISTORY */
        .stats-table { width: 100%; border-collapse: collapse; font-size: 12px; margin-top: 10px; }
        .stats-table th, .stats-table td { padding: 10px; text-align: center; border-bottom: 1px solid #444; }
        .stats-table th { background: #333; cursor: pointer; user-select: none; }
        .stats-table th.active-sort { background: #444; color: var(--accent-gold); }
        .profit-pos { color: var(--accent-green); } .profit-neg { color: var(--accent-red); }
        
        .history-item { background: #252525; border-radius: 8px; margin-bottom: 10px; overflow: hidden; border: 1px solid #333; }
        .history-item.favorite { border: 2px solid var(--accent-gold); }
        .history-header { background: #333; padding: 8px; display: flex; justify-content: space-between; align-items: center; font-size: 12px; font-weight: bold; }
        .history-board { padding: 8px; background: #1e3a28; display: flex; gap: 4px; justify-content: center; border-bottom: 1px solid #333; }
        .history-winners { padding: 8px; background: rgba(46, 204, 113, 0.1); border-bottom: 1px solid #333; }
        .winner-line { color: var(--accent-green); font-size: 13px; font-weight: bold; display: flex; justify-content: space-between; }
        .history-hands { padding: 8px; }
        .hand-line { display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px; font-size: 12px; }
        .mini-cards { display: flex; gap: 2px; }

        /* Card Selector */
        .suit-grid { display: flex; gap: 10px; margin-bottom: 15px; } .suit-btn { flex: 1; font-size: 30px; padding: 12px; background: #333; border: 2px solid #444; border-radius: 8px; } .suit-btn.selected { background: #555; border-color: #fff; }
        .rank-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; } 
        .rank-btn { padding: 15px; background: #333; border: 1px solid #444; border-radius: 8px; font-size: 18px; font-weight: bold; }
        .rank-btn.disabled { opacity: 0.15; cursor: not-allowed; background: #000 !important; color: #444; border-color: #222; pointer-events: none; }
        
        /* REPLAY STYLES */
        .replay-container { position: relative; width: 100%; height: 380px; margin: 20px 0; display: flex; align-items: center; justify-content: center; }
        .replay-table-bg { width: 85=0%; height: 220px; background: #1e3a28; border: 5px solid #27ae60; border-radius: 120px; position: relative; display: flex; flex-direction: column; justify-content: center; align-items: center; box-shadow: inset 0 0 50px rgba(0,0,0,0.8); }
		.replay-player { 
			position: absolute; 
			background: #222; 
			border: 1px solid #444; 
			border-radius: 6px; 
			font-size: 9px; 
			width: 60px; 
			text-align: center; 
			z-index: 10; 
			transition: all 0.3s ease;
    
			/* Spacing to ensure Name isn't covered by Dealer Btn */
			padding-top: 6px;    
			/* Spacing to ensure Name isn't covered by Bet Pill */
			padding-bottom: 8px; 
			padding-left: 2px;
			padding-right: 2px;
		}
        .replay-player.folded { opacity: 0.5; filter: grayscale(1); }
        .replay-player.winner { border-color: var(--accent-green) !important; box-shadow: 0 0 15px var(--accent-green) !important; z-index: 100; background: rgba(46, 204, 113, 0.2); }
		.replay-action-pill { 
			position: absolute; 
			bottom: -9px; /* Sit nicely on the bottom edge */
			left: 50%; 
			transform: translateX(-50%); 
    
			/* VITAL FIX: Prevents stretching */
			width: max-content; 
			min-width: 20px;
			white-space: nowrap;

			background: var(--accent-gold); 
			color: black; 
			font-weight: bold; 
			font-size: 8px; 
			padding: 2px 6px; 
			border-radius: 10px; 
			z-index: 28; 
			border: 1px solid white;
			box-shadow: 0 2px 4px rgba(0,0,0,0.5);
		}
        .replay-cards { display: flex; gap: 2px; margin-top: 2px; justify-content: center; min-height: 18px; }
        .replay-cards .card-visual {
     width: calc(var(--card-width) * var(--replay-card-scale));
     height: calc(var(--card-height) * var(--replay-card-scale));
     font-size: 10px; /* Keep font size readable */
}		
.replay-cards .card-visual.small {
     width: 12px; height: 16px; font-size: 8px; 
}
		/* Fix for replay board stacking */
        #replay-board { display: flex; flex-direction: column; gap: 5px; align-items: center; width: 100%; }
        
        /* New Bet Control Styles */
        .bet-adjust-row { display: flex; gap: 10px; margin-bottom: 10px; }
        .btn-adjust { flex: 1; padding: 12px; background: #444; border: 1px solid #555; border-radius: 6px; color: white; font-weight: bold; font-size: 16px; cursor: pointer; }
        .btn-adjust:active { background: #666; }
        .num-pad { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 5px; } 
        .num-btn { padding: 15px; background: #333; color: white; font-size: 20px; border: none; border-radius: 5px; }
        .btn-backspace { background: #552222; color: #ffaaaa; }
        
        .pause-overlay { position: absolute; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.8); backdrop-filter: blur(4px); z-index: 50; display: none; flex-direction: column; align-items: center; justify-content: center; } .pause-overlay.visible { display: flex; }
        #nit-overlay { background: rgba(0,0,0,0.95); z-index: 3000; }
        
        .tab-nav { display: flex; gap: 5px; margin-bottom: 15px; }
        .tab-btn { flex: 1; padding: 12px; background: #333; border: none; color: #888; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .tab-btn.active { background: var(--accent-blue); color: white; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        /* New Winner Modal */
        #modal-winner { z-index: 4000; background: rgba(0,0,0,0.9); }
        .winner-content { background: linear-gradient(145deg, #1e2d3d, #0f1821); padding: 30px; border-radius: 15px; border: 4px solid var(--accent-gold); box-shadow: 0 0 40px rgba(241, 196, 15, 0.4); text-align: center; }
        .winner-amount { font-size: 48px; color: var(--accent-green); font-weight: 900; margin: 10px 0; }
        .winner-hand { font-size: 20px; color: var(--accent-gold); font-style: italic; margin-top: 5px; }

        .btn-fav { background: none; border: none; cursor: pointer; font-size: 18px; color: #555; transition: color 0.2s; } .btn-fav.active { color: var(--accent-gold); }
        
        /* TOGGLE SWITCH */
        .switch-container { display: flex; align-items: center; justify-content: space-between; background: #333; padding: 10px; border-radius: 8px; margin-bottom: 10px; }
        .switch-label { font-weight: bold; color: white; font-size: 14px; }
        .switch-toggle { position: relative; width: 50px; height: 26px; background: #555; border-radius: 13px; cursor: pointer; transition: 0.3s; }
        .switch-toggle.on { background: var(--accent-green); }
        .switch-circle { position: absolute; left: 3px; top: 3px; width: 20px; height: 20px; background: white; border-radius: 50%; transition: 0.3s; }
        .switch-toggle.on .switch-circle { transform: translateX(24px); }

		/* --- REPLAY VISUALS (Casino Stacks) --- */

/* 1. MODAL SIZE: Allow the modal to grow, but constrain the content for a good viewing experience. */
.modal-content {
    /* Revert to original goal, but make height proportional */
    width: 95%; 
    max-width: 800px; /* Allow it to be wide on desktop */
    max-height: 95vh; /* Allow it to use most of the screen height */
    /* Remove fixed height/dvh settings from here: height: 75dvh; max-height: 400px; */
    
    display: flex; flex-direction: column;
}

/* 2. REPLAY STAGE: The area holding the table and players. Use flex: 1 for space, and an aspect-ratio-friendly container. */
.replay-container {
    position: relative; 
    width: 100%; 
    padding-top: 60%; /* 60% of the 100% width creates a 5:3 aspect ratio (Wide enough for 10 players) */
    height: 0; /* Important: Override the fixed height with padding-top for aspect ratio */
    margin: 20px 0; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
}

/* 3. TABLE BACKGROUND: Positioned absolutely inside the aspect-ratio container to fill it. */
.replay-table-bg {
    position: absolute; /* Positioned inside .replay-container */
    top: 0; left: 0; 
    width: 90%; 
    height: 90%; 
    margin: 5% 5%; /* Center it within the container */
    
    background: #1e3a28; 
    border: 5px solid #27ae60; 
    border-radius: 120px; 
    display: flex; 
    flex-direction: column; 
    justify-content: center; 
    align-items: center; 
    box-shadow: inset 0 0 50px rgba(0,0,0,0.8);
    
    /* Remove padding-top/height overrides from previous attempt */
    padding-top: 0;
    height: 90%;
}

/* 4. PLAYER POSITION & SIZE SCALING: */
.replay-player { 
    position: absolute; 
    background: #222; 
    border: 1px solid #444; 
    padding: 3px; 
    border-radius: 6px; 
    font-size: 9px; 
    width: 60px; /* Keep this fixed, but positioning is key */
    text-align: center; 
    z-index: 10; 
    transition: all 0.3s ease; 
}

/* --- RE-POSITIONING (This is the most critical fix for mobile overflow) --- */
/* The players are positioned using a radius (45 * sin/cos) on the parent (.replay-container). */
/* By shrinking the radius in the JS *and* ensuring the parent is the right size, this works. */

/* *** JS ADJUSTMENT (FOR YOUR REFERENCE, NOT CSS): *** */
/* In renderReplayStep function, you used a radius of 45:
   const xPos = 50 + 45 * Math.cos(angle - Math.PI/2); 
   const yPos = 50 + 45 * Math.sin(angle - Math.PI/2);
   
   To pull the players INWARD to ensure they don't clip the 100% boundary of the responsive container,
   you should reduce the radius slightly, e.g., to 42.
   
   // CHANGE in JS (renderReplayStep) TO:
   const xPos = 50 + 42 * Math.cos(angle - Math.PI/2); 
   const yPos = 50 + 42 * Math.sin(angle - Math.PI/2);
*/

/* 5. BET/CHIP SCALING */
.chip-row-bet { scale: 0.8; } /* Already set, good for scaling on small players */


/* Chip Architecture (Rest of your existing code is fine) */
.chip-row {
    display: flex; align-items: flex-end; gap: 2px;
    position: absolute; 
    left: 110%; bottom: 0px; 
    z-index: 21; 
    filter: drop-shadow(0px 2px 2px rgba(0,0,0,0.5));
    pointer-events: none;
}

.chip-col {
    display: flex; flex-direction: column-reverse; 
    margin-bottom: -5px; 
}

/* Pot Override */
.pot-visual .chip-col { margin-bottom: -5px; }

.chip {
    width: 18px; height: 18px; border-radius: 50%; 
    margin-top: -15px; 
    border: 2px dashed rgba(255,255,255,0.6); 
    box-shadow: inset 0 0 5px rgba(0,0,0,0.5), 0 2px 1px rgba(0,0,0,0.3);
    position: relative;
    background-size: cover;
}
.chip::after { 
    content:''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    width: 8px; height: 8px; border: 1px solid rgba(255,255,255,0.3); border-radius: 50%;
}

/* Chip Colors */
.chip.black { background: #2c3e50; border-color: #eee; } 
.chip.green { background: #27ae60; border-color: #eee; } 
.chip.red   { background: #c0392b; border-color: #eee; } 
.chip.blue  { background: #3498db; border-color: #eee; } 
.chip.white { background: #ecf0f1; border-color: #bdc3c7; } 

.dealer-btn-large {
    width: 16px; height: 16px; 
    background: #fff; border: 2px solid #000; color: #000; 
    border-radius: 50%; font-weight: bold; font-size: 9px; 
    display: flex; align-items: center; justify-content: center; 
    position: absolute;
    top: -6px; left: -6px; /* Corner position */
    z-index: 25; 
    box-shadow: 1px 1px 2px rgba(0,0,0,0.8);
}
@keyframes bounce { from { transform: translateX(-50%) translateY(0); } to { transform: translateX(-50%) translateY(-5px); } }
        
        .all-in-triangle {
			width: 0; height: 0; 
			border-left: 8px solid transparent;
			border-right: 8px solid transparent;
			border-bottom: 12px solid #e74c3c;
			position: absolute; 
    
			/* Moved from -32px to -40px to give plenty of space */
			top: -40px; 
    
			left: 50%; transform: translateX(-50%); 
			z-index: 30;
			filter: drop-shadow(0px 2px 2px rgba(0,0,0,0.5));
			animation: bounce 1s infinite alternate;
		}
		.all-in-triangle::after {
			content: 'ALL IN'; position: absolute; top: 14px; left: -20px; width: 40px;
			font-size: 7px; color: #e74c3c; font-weight: bold; text-align: center; text-transform:uppercase;
			text-shadow: 0px 0px 2px black;
		}
        @keyframes bounce { from { transform: translateX(-50%) translateY(0); } to { transform: translateX(-50%) translateY(-5px); } }
        /* RIMT & Manual Win Specific */
        .manual-winner-item { padding: 12px; margin-bottom: 5px; background: #333; border: 2px solid #444; border-radius: 6px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .manual-winner-item.selected { border-color: var(--accent-green); background: #1e3a28; }
        .manual-check { font-size: 20px; color: #555; } .manual-winner-item.selected .manual-check { color: var(--accent-green); }

        .rimt-tabs { display: flex; gap: 5px; margin-bottom: 15px; overflow-x: auto; padding-bottom: 5px; border-bottom: 1px solid #444; padding-bottom: 10px;}
        .rimt-tab { flex: 1; padding: 10px; background: #333; border: 1px solid #444; border-radius: 8px; color: #aaa; font-size: 14px; cursor: pointer; text-align: center; white-space: nowrap; }
        .rimt-tab.active { background: var(--accent-gold); color: black; border-color: var(--accent-gold); font-weight: bold; }
        
        /* Modal Controls */
        .modal-controls-row { display: flex; justify-content: space-between; gap: 10px; margin-bottom: 15px; }
        .modal-select { flex: 1; background: #333; color: white; border: 1px solid #555; border-radius: 8px; padding: 10px; font-size: 14px; font-weight: bold; outline: none; -webkit-appearance: none; text-align-last: center; }
		/* --- PASTE THIS AT THE END OF YOUR <style> SECTION --- */

/* 1. Fix Replay Board Visibility & Pot Overlap */
.replay-table-bg {
    justify-content: center; 
    align-items: center; 
    z-index: 1; 
}

/* Ensure the board sits in the absolute center */
#replay-board { 
    z-index: 5; 
    position: relative;
    margin-top: 15%; /* Push board down so Pot can sit above it */
}

/* 2. Pot Positioning - Center Table but North */
.pot-visual {
    position: absolute;
    top: 30%; 
    left: 50%;
    transform: translateX(-50%) translateY(-50%);
    z-index: 6;
    pointer-events: none;
    transition: all 0.5s ease;
}

/* 3. Black Dealer Button */
.dealer-btn-large {
    width: 18px; height: 18px; 
    background: #fff; 
    border: 2px solid #000; 
    color: #000; 
    border-radius: 50%; 
    font-weight: bold; font-size: 9px; 
    display: flex; align-items: center; justify-content: center; 
    position: absolute;
    /* Move to top-left corner, slightly overflowing */
    top: -8px; left: -8px; 
    z-index: 25; 
    box-shadow: 1px 1px 2px rgba(0,0,0,0.8);
}

/* 4. Skull Icon for Busted Players */
.skull-icon {
    font-size: 24px;
    position: absolute;
    top: -30px; left: 50%;
    transform: translateX(-50%);
    z-index: 30;
    filter: drop-shadow(0px 2px 2px rgba(0,0,0,0.8));
    animation: bounce 1s infinite alternate;
}

/* Fix All-In Triangle Position */
.all-in-triangle {
    top: -25px; /* High above the box */
    left: 50%; transform: translateX(-50%); 
    z-index: 30;
}
/* --- MOBILE LAYOUT FIXES (Paste at the very bottom of <style>) --- */
@media screen and (max-width: 768px) {
    /* 1. Move the Board UP to clear the bottom player's chips/icons */
    #replay-board {
        margin-top: 0% !important; /* Reduced from 15% */
    }

    /* 2. Move the Pot UP to stay synchronized with the board */
    .pot-visual {
        top: 20% !important; /* Reduced from 30% */
    }

    /* 3. Scale down Player Box slightly */
    .replay-player {
        padding: 1px !important;
        width: 55px !important; /* Make player box slightly narrower */
        font-size: 8px !important; /* Smaller text */
    }

    /* 4. Shrink the Skull & All-In Icon so they don't reach the board */
    .skull-icon {
        font-size: 16px !important; /* Smaller skull */
        top: -22px !important; /* Pull it closer to the player name */
    }
    .all-in-triangle {
        border-bottom: 12px solid #e74c3c !important; /* Smaller triangle */
        top: -12px !important; 
    }
    
    /* 5. Shrink Chips slightly to save vertical space */
    .replay-player .chip {
        width: 14px !important; 
        height: 14px !important;
        margin-top: -11px !important; /* Tighten the stack */
    }
    
    /* 6. Adjust the chip container position to be tighter */
    .chip-row-bet {
		bottom: -15px; /* Push bets lower down */
		scale: 0.7;
		z-index: 20;
	}
}
	/* Update Winner Modal to accommodate the Undo Button */
.winner-content {
    background: linear-gradient(145deg, #1e2d3d, #0f1821); 
    padding: 20px; 
    border-radius: 15px; 
    border: 4px solid var(--accent-gold); 
    box-shadow: 0 0 40px rgba(241, 196, 15, 0.4); 
    text-align: center; 
    min-width: 300px;
}
.btn-undo-win {
    background: #444; 
    border: 1px solid #777; 
    color: #ccc; 
    padding: 8px 15px; 
    border-radius: 20px; 
    font-size: 12px; 
    margin-top: 15px; 
    cursor: pointer; 
    display: inline-flex; 
    align-items: center; 
    gap: 5px;
}
.btn-undo-win:hover { background: #555; color: white; border-color: white; }
/* --- PLAYER / TV VIEW MODE --- */
body.player-view-mode .controls, 
body.player-view-mode .setup-container,
body.player-view-mode .street-btn, 
body.player-view-mode .header-right, 
body.player-view-mode #context-menu,
body.player-view-mode .btn-edit-stack,
body.player-view-mode .role-btn {
    display: none !important;
}

/* Ensure Dealer/Blind buttons remain visible on TV */
body.player-view-mode .role-btn.dealer-btn,
body.player-view-mode .role-btn.sb-btn,
body.player-view-mode .role-btn.bb-btn {
    display: flex !important;
}

/* Layout Adjustments for Big Screen */
body.player-view-mode header {
    justify-content: center; /* Center the pot */
    height: 100px;
}

body.player-view-mode .pot-display {
    font-size: 60px; /* Make pot huge */
    transform: scale(1.2);
}

body.player-view-mode .table-area {
    height: calc(100vh - 100px); /* Full height minus header */
    padding-bottom: 0;
}

/* Make Cards Larger on Player Screen */
body.player-view-mode .card-visual {
    width: 50px;
    height: 70px;
    font-size: 24px;
}
body.player-view-mode .card-visual.small {
    width: 25px;
    height: 35px;
    font-size: 14px;
}
/* Hide the setup screen when game is active in player mode */
body.player-view-mode #view-setup {
    display: none !important;
}
body.player-view-mode #view-game {
    display: flex !important;
}
/* --- TABLET/DENSITY FIXES --- */

/* 1. On Tablets (Wider Screens), force 3 Columns so you don't have to scroll */
@media (min-width: 600px) {
    .table-area {
        grid-template-columns: repeat(3, 1fr) !important; 
    }
}

/* 2. DENSE MODE: Active when players > 8 */
.dense-mode .player-card {
    min-height: 70px !important; /* Shrink height */
    padding: 4px !important;
}

.dense-mode .p-name {
    font-size: 11px !important;
    margin-bottom: 0px !important;
}

.dense-mode .p-stack {
    font-size: 11px !important;
    margin-top: 0px !important;
}

/* Shrink the Action Text (e.g. "BET 20") */
.dense-mode .p-action {
    font-size: 9px !important;
    min-height: 12px !important;
    margin-top: 1px !important;
}

/* Shrink the Cards so they fit INSIDE the box */
.dense-mode .card-visual {
    width: 22px !important;
    height: 30px !important;
    font-size: 12px !important;
    border-radius: 3px !important;
}

/* Tighter spacing for the card container */
.dense-mode .p-cards {
    margin-top: 2px !important;
    gap: 2px !important;
    justify-content: center;
}

/* Adjust Dealer Button position in dense mode */
.dense-mode .role-btn {
    width: 18px !important;
    height: 18px !important;
    font-size: 9px !important;
    top: -5px !important;
    left: -5px !important;
}

/* Adjust Nit/All-in badges for dense mode */
.dense-mode .nit-chip { width: 20px; height: 20px; font-size: 7px; }

/* --- REPLAY SIZE FIXES --- */

/* 1. Make the Player Box Bigger */
.replay-player {
    width: 80px !important;       /* Was 60px */
    font-size: 11px !important;   /* Was 9px */
    padding: 6px 4px !important;
}

/* 2. Make the Action Pill (Bet Amount) Bigger */
.replay-action-pill {
    font-size: 10px !important;   /* Was 8px */
    padding: 3px 8px !important;
    bottom: -11px !important;
}

/* 3. Make the Cards Bigger */
.replay-cards .card-visual {
    width: 26px !important;       /* Bigger cards */
    height: 36px !important;
    font-size: 14px !important;
}
.replay-cards .card-visual.small {
    width: 16px !important;       /* Bigger mini cards (folded/back) */
    height: 22px !important;
}

/* 4. Make the Chips bigger */
.chip-row-bet {
    scale: 1.0 !important;        /* Reset scale */
    bottom: -18px !important;     /* Move down to not cover name */
}
/* --- PRO STATS / HUD STYLES --- */
.stat-cell { font-family: 'Roboto Mono', monospace; font-weight: bold; font-size: 13px; }
.stat-label { font-size: 10px; color: #777; display: block; margin-bottom: 2px; }
.stat-val { display: inline-block; padding: 2px 6px; border-radius: 4px; background: rgba(255,255,255,0.05); }

/* HUD Color Coding */
.stat-green { color: #2ecc71; text-shadow: 0 0 5px rgba(46, 204, 113, 0.3); } /* Loose / Aggressive / Profit */
.stat-red   { color: #e74c3c; } /* Tight / Passive / Loss */
.stat-gold  { color: #f1c40f; } /* High Activity */
.stat-gray  { color: #777; }    /* N/A */

.stats-table th { font-size: 10px; text-transform: uppercase; letter-spacing: 1px; color: #aaa; }

	</style>
	<script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
	<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
	</head>
<body onclick="hideContextMenu()">

    <div id="context-menu">
        <div class="ctx-item" onclick="setManualRole('dealer')">‚ö™Ô∏è Set Dealer (Restarts Hand)</div>
        <div class="ctx-item" onclick="setManualRole('sb')">üü£ Set Small Blind</div>
        <div class="ctx-item" onclick="setManualRole('bb')">‚ö´Ô∏è Set Big Blind</div>
        <div style="height:1px; background:#444; margin:0 5px;"></div>
        <div class="ctx-item" style="color:var(--accent-gold);" onclick="trigger72Game()">üí∞ Claim 7-2 Win</div>
        <div style="height:1px; background:#444; margin:0 5px;"></div>
        <div class="ctx-item" style="color:#f55;" onclick="setManualRole('clear')">‚ùå Remove Role</div>
    </div>

    <div id="modal-winner" class="modal" onclick="closeWinnerModal()">
        <div class="winner-content">
            <h2 style="color:white; font-size:24px;">WINNER</h2>
            <div id="winner-name-display" style="font-size:30px; font-weight:bold; color:var(--accent-green);"></div>
            <div class="winner-amount">+‚Ç¨<span id="winner-amount-display"></span></div>
            <div class="winner-hand" id="winner-hand-display"></div>
            <div style="color:#aaa; font-size:12px; margin-top:20px;">(Tap to continue)</div>
        </div>
    </div>
    
    <div id="modal-manual-win" class="modal">
    <div class="modal-content">
        <h2>Select Winner(s)</h2>
        
        <button class="btn" style="background:linear-gradient(45deg, #8e44ad, #3498db); margin-bottom:15px; font-weight:bold; border:1px solid white;" onclick="performAutoShowdown()">ü™Ñ Auto-Detect Winner</button>
        
        <div style="background:#333; height:1px; margin:10px 0;"></div>
        <p style="color:#aaa; font-size:12px; text-align:center;">MANUAL MODE: Select winners for each pot below.</p>
        
        <div id="manual-pot-container" style="display:flex; flex-direction:column; gap:10px; max-height:40vh; overflow-y:auto;"></div>

        <div style="margin-top:15px; background:#222; padding:10px; border-radius:6px; border:1px solid #444; display:flex; align-items:center; justify-content:space-between;">
            <label for="manual-72-claim" style="font-size:13px; color:#f1c40f; font-weight:bold;">ü§† Claim 7-2 Bounty?</label>
            <input type="checkbox" id="manual-72-claim" style="transform:scale(1.5);">
        </div>

        <div style="margin-top:15px; border-top:1px solid #444; padding-top:10px; display:flex; gap:10px;">
            <button class="btn" style="background:#444; flex:1;" onclick="closeModal('modal-manual-win')">Cancel</button>
            <button class="btn-primary" style="flex:1; margin-top:0;" onclick="confirmManualWin()">Confirm Distribution</button>
        </div>
    </div>
</div>
    
    <div id="modal-bust" class="modal">
        <div class="modal-content">
            <h2 style="color: var(--accent-red); text-align: center;">Players Busted!</h2>
            <p style="text-align: center; color: #aaa; margin-bottom: 15px;">Resolve busts before starting the next hand.</p>
            <div id="bust-list"></div>
            <button class="btn-primary" onclick="processBustsAndContinue()">Start Next Hand</button>
        </div>
    </div>
    
    <div id="modal-adjust-stack" class="modal">
    <div class="modal-content" style="max-width:300px;">
        <h3>Edit Player Stack</h3>
        
        <label>Current Stack</label>
        <input type="number" id="adjust-stack-input">

        <label>Initial Buy-In</label>
        <input type="number" id="adjust-buyin-input">

        <label>Total Rebuy Amount</label>
        <input type="number" id="adjust-rebuy-amt-input">

        <label>Rebuy Count (Times)</label>
        <input type="number" id="adjust-rebuy-count-input">

        <div style="display:flex; gap:10px; margin-top:15px;">
            <button class="btn" style="background:#444; flex:1" onclick="closeModal('modal-adjust-stack')">Cancel</button>
            <button class="btn-primary" style="flex:1; margin-top:0;" onclick="saveStackAdjustment()">Save Fix</button>
        </div>
    </div>
</div>
	<div id="modal-bomb-settings" class="modal">
        <div class="modal-content">
            <h2 style="color:var(--accent-red);">üí£ Bomb Pot Setup</h2>
            <p style="text-align:center; color:#aaa; margin-bottom:15px;">Double Board PLO: 5 cards each, 2 boards. Split pot between best high hand on each board.</p>
            
            <label>Ante Amount (Per Player)</label>
            <input type="number" id="bomb-ante" value="5">
            
            <label style="margin-top:10px;">Select Players</label>
            <div id="bomb-player-list" style="display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-bottom:15px;"></div>
            
            <button class="btn-primary" onclick="startBombPot()">üí• DEAL BOMB POT</button>
            <button class="btn" style="background:#444; margin-top:10px;" onclick="closeModal('modal-bomb-settings')">Cancel</button>
        </div>
    </div>
    <div id="modal-nit-settings" class="modal">
        <div class="modal-content">
            <h2>ü§° Nit Game Settings</h2>
            
            <div class="switch-container">
                <div class="switch-label">Nit Game Active</div>
                <div class="switch-toggle" id="sw-nit-active" onclick="toggleNitSetting('active')"><div class="switch-circle"></div></div>
            </div>

            <div class="switch-container">
                <div class="switch-label">Double Nit (2 Buttons Each)</div>
                <div class="switch-toggle" id="sw-double-nit" onclick="toggleNitSetting('double')"><div class="switch-circle"></div></div>
            </div>
            
            <label style="margin-top:10px;">Penalty Mode</label>
            <div style="display:flex; gap:5px; margin-bottom:15px;">
                <button class="btn" id="btn-mode-splash" style="flex:1;" onclick="setNitMode('splash')">Splash Pot</button>
                <button class="btn" id="btn-mode-pay" style="flex:1;" onclick="setNitMode('pay')">Pay Table</button>
            </div>
            
            <label>Penalty Amount</label>
            <input type="number" id="nit-penalty-amount" value="5">
            
            <label style="margin-top:10px;">Custom Loser Message</label>
            <input type="text" id="nit-custom-msg" placeholder="e.g. Is a Fucken NIT">
            
            <div style="display:flex; gap:10px; margin-top:20px;">
                <button class="btn" style="background:#444; flex:1;" onclick="closeModal('modal-nit-settings')">Cancel</button>
                <button class="btn-primary" style="flex:1; margin-top:0;" onclick="saveNitSettings()">Save</button>
            </div>
        </div>
    </div>
	
    <div id="view-setup" class="view active">
        <div class="setup-container">
    <h1>‚ô†Ô∏è Ultimate Dealer V1</h1>
    
    <div class="form-group"><label>Session Name</label><input type="text" id="session-name" value="Poker Night"></div>
    
    <div class="form-group">
        <label>Stakes (SB / BB / Ante)</label>
        <div style="display:flex; gap:5px; margin-top:5px;">
            <input type="number" id="sb-amount" value="0.20" placeholder="SB">
            <input type="number" id="bb-amount" value="0.40" placeholder="BB">
            <input type="number" id="ante-amount" value="0.10" placeholder="Ante">
        </div>
    </div>
    
    <div class="form-group">
        <label>Betting Controls</label>
        <label>Bet Increment (Step)</label>
        <input type="number" id="bet-increment" value="0.20">
    </div>
    
    <div class="form-group"><label>Buy-ins (Min/Max)</label><div style="display:flex; gap:10px;"><input type="number" id="min-buyin" value="20" onchange="generatePlayerInputs()"><input type="number" id="max-buyin" value="100"></div></div>
    
    <div class="form-group">
        <label>Game Mode</label>
        <div class="switch-container" style="margin-top:5px; background:#222; padding:10px; border-radius:6px;">
            <div class="switch-label">
                <span id="setup-mode-title" style="color:var(--accent-green); font-weight:bold;">Casual Mode</span>
                <div id="setup-mode-desc" style="font-size:10px; color:#888; font-weight:normal;">Infinite stacks. Track bets & scores only.</div>
            </div>
            <div class="switch-toggle on" id="sw-casual-setup" onclick="toggleSetupCasual()"><div class="switch-circle"></div></div>
        </div>
    </div>
    
    <div class="form-group">
        <label>Players (2-12)</label>
        <select id="player-count" onchange="generatePlayerInputs()">
            <option value="2">2</option><option value="3">3</option><option value="4">4</option>
            <option value="5">5</option><option value="6" selected>6</option><option value="7">7</option>
            <option value="8">8</option><option value="9">9</option><option value="10">10</option>
            <option value="11">11</option><option value="12">12</option>
        </select>
        <div id="player-inputs" style="margin-top:10px;"></div>
    </div>

    <button class="btn-primary" onclick="startGame()">Start Game</button>
    <button class="btn" style="background:#333; width:100%; margin-top:10px;" onclick="restoreGame()">Resume</button>

    <input type="file" id="startScreenLoader" style="display:none" accept="*/*" onchange="loadSessionFile(this)">
    <button class="btn" style="background:#2196F3; width:100%; margin-top:10px;" onclick="document.getElementById('startScreenLoader').click()">
        üìÇ Load Game
    </button>
    </div>
    </div>

    <div id="view-game" class="view">
        <div id="pause-overlay" class="pause-overlay">
            <h2 style="color:var(--accent-gold);">PAUSED</h2>
            <div style="color:white; font-size:12px; margin-bottom:20px;">Timer Paused</div>
            <button class="btn" style="background:var(--accent-green); padding:15px; margin-bottom:10px; width:200px;" onclick="togglePause()">RESUME</button>
            <button class="btn" style="background:var(--accent-blue); padding:15px; width:200px;" onclick="openMenuModal()">OPEN MENU</button>
        </div>
        
        <div id="nit-overlay" class="pause-overlay" onclick="closeNitAlert()"><div style="font-size:80px; margin-bottom:20px;">ü§°</div><h2 style="color:var(--accent-red); text-align:center; padding: 20px;" id="nit-loser-msg"></h2><p style="color:#aaa;">(Tap to continue)</p></div>

        <header>
            <div class="header-left">
                <button class="street-btn" onclick="openBoardSelector()" id="street-name">PREFLOP</button>
            </div>
            <div class="header-center">
                <div class="pot-display">‚Ç¨<span id="pot-amount">0</span></div>
            </div>
            <div class="header-right">
                <button class="clock-btn" id="live-fav-btn" onclick="toggleLiveFavorite()" style="font-size:18px; line-height:1; padding:2px 8px;">‚òÜ</button>
                
                <button class="pause-btn" id="main-pause-btn" onclick="togglePause()">‚è∏</button>
                <button class="clock-btn" id="shot-clock-btn" onclick="addShotClock()">+30s</button>
                <div style="font-size:10px; color:#666; margin-top:2px; text-align:right;">Hand #<span id="hand-number">1</span></div>
            </div>
        </header>

        <div id="board-area" onclick="openBoardSelector()">
            </div>
        
        <div class="table-area" id="table-grid"></div>

        <div class="controls">
            <div class="control-row row-1">
                <button class="btn btn-bet" onclick="openActionModal('bet')">BET</button><button class="btn btn-call" id="btn-call" onclick="handleCall()">CALL</button><button class="btn btn-fold" onclick="handleFold()">FOLD</button><button class="btn btn-win" onclick="handleWinner()">WIN</button>
            </div>
            <div class="control-row row-2">
                <button class="btn btn-straddle" onclick="handleStraddle()">STRAD</button><button class="btn btn-undo" onclick="undoLastAction()">UNDO</button><button class="btn btn-next" id="btn-next" onclick="nextStreet()">NEXT</button><button class="btn btn-card" onclick="handleCardButton()">CARDS</button><button class="btn btn-manage" onclick="openMenuModal()">MENU</button>
            </div>
        </div>
    </div>

    <div id="modal-replay" class="modal">
        <div class="modal-content">
            <h2>Hand #<span id="replay-hand-id"></span></h2>
            
            <div style="text-align:center; color:var(--accent-green); font-weight:bold; margin-bottom: 5px;">
                Pot: <span id="replay-pot">0</span>
            </div>
            
            <div class="replay-container" id="replay-stage">
                <div class="replay-table-bg">
                    <div id="replay-board"></div> 
                </div>
            </div>
            <div style="text-align:center; margin-bottom:15px; font-weight:bold; color:#aaa; font-size:14px;" id="replay-log-text"></div>
            <div style="display:flex; gap:10px;"><button class="btn" style="background:#444;" onclick="replayStep(-1)">PREV</button><button class="btn" style="background:var(--accent-gold); color:black;" onclick="replayStep(1)">NEXT</button></div>
            <button class="btn" style="background:#333; margin-top:10px;" onclick="backToHistory()">Back</button>
        </div>
    </div>
    
    <div id="modal-rebuy" class="modal">
        <div class="modal-content">
            <h2>Rebuy / Add-on</h2>
            <div style="text-align:center; color:#aaa; margin-bottom:10px;">Player: <span id="rebuy-player-name" style="color:white; font-weight:bold;"></span></div>
            <label>Amount (Min: <span id="rebuy-min"></span>, Max: <span id="rebuy-max"></span>)</label>
            <input type="number" id="rebuy-amount" placeholder="Amount">
            <button class="btn-primary" onclick="confirmRebuy()">Confirm Rebuy</button>
            <button class="btn" style="background:#444; margin-top:10px;" onclick="closeModal('modal-rebuy')">Cancel</button>
        </div>
    </div>

    <div id="modal-menu" class="modal">
    <div class="modal-content">
        <div class="tab-nav">
            <button class="tab-btn active" onclick="switchTab('tab-manage', this)">Game</button>
            <button class="tab-btn" onclick="switchTab('tab-stats', this)">Basic Stats</button>
            <button class="tab-btn" onclick="switchTab('tab-advanced', this)">Advanced Stats</button>
            <button class="tab-btn" onclick="switchTab('tab-history', this)">History</button>
        </div>
        
        <div id="tab-manage" class="tab-content active">
            <div style="display:flex; gap:10px; margin-bottom:15px;">
                <button class="btn" style="background:#ff6b6b; flex:1" onclick="openNitSettings()">NIT GAME</button>
                <button class="btn" style="background:var(--accent-red); flex:1" onclick="openBombSettings()">üí£ BOMB POT</button>
            </div>
            
            <div style="margin-bottom:15px;">
                <div style="display:flex; gap:10px; margin-bottom:10px;">
                    <button class="btn" id="btn-auto-win" style="background:#555; flex:1;" onclick="toggleAutoDetect()">AUTO WIN: OFF</button>
                    <button class="btn" id="btn-casual-mode" style="background:#555; flex:1;" onclick="toggleCasualMode()">CASUAL: OFF</button>
                </div>
            </div>

            <div id="manage-list"></div>
            
            <button class="btn" style="background:var(--accent-blue); width:100%; margin-top:15px;" onclick="addNewPlayer()">Add Player</button>
            
            <button class="btn" style="background-color: #D32F2F; width:100%; margin-top: 15px;" onclick="openSettlementModal()">
                üèÅ End Session & Settlement
            </button>

            <button class="btn" style="background:#444; width:100%; margin-top:10px;" onclick="closeModal('modal-menu')">Back</button>
        </div>
        
        <div id="tab-stats" class="tab-content">
            <table class="stats-table" id="stats-table">
                <thead>
                    <tr>
                        <th onclick="renderStats('name', 'basic')">Player</th>
                        <th onclick="renderStats('profit', 'basic')">Profit/Loss</th>
                        <th onclick="renderStats('buyin', 'basic')">Initial Buy-in</th>
                        <th onclick="renderStats('rebuy', 'basic')">Rebuys</th>
                        <th onclick="renderStats('nit', 'basic')">NIT Charges</th>
                        <th onclick="renderStats('time', 'basic')">Avg Time</th>
                        <th onclick="renderStats('72', 'basic')">7-2</th>
                        <th onclick="renderStats('bomb', 'basic')">üí£ Win</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
            <button class="btn" style="background:#444; width:100%; margin-top:10px;" onclick="closeModal('modal-menu')">Back</button>
        </div>
        
        <div id="tab-advanced" class="tab-content">
            <div style="background:#222; padding:10px; margin-bottom:10px; border-radius:8px; font-size:11px; color:#888; display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
                <span><b style="color:#fff">VPIP:</b> Voluntarily Put $ In Pot</span>
                <span><b style="color:#fff">PFR:</b> Pre-Flop Raise</span>
                <span><b style="color:#fff">AFq:</b> Aggression Freq</span>
                <span><b style="color:#fff">WSD:</b> Won Showdown %</span>
                <span><b style="color:#fff">WTSD:</b> Went to Showdown %</span>
            </div>
            <table class="stats-table" id="advanced-stats-table">
                <thead>
                    <tr>
                        <th onclick="renderStats('name', 'advanced')">PLAYER</th>
                        <th title="Voluntarily Put Money In Pot %" onclick="renderStats('vpip', 'advanced')">VPIP</th>
                        <th title="Pre-Flop Raise %" onclick="renderStats('pfr', 'advanced')">PFR</th>
                        <th title="3-Bet % (Re-raise Pre-flop)" onclick="renderStats('3bet', 'advanced')">3-BET</th>
                        <th title="Aggression Frequency % (Post-flop)" onclick="renderStats('afq', 'advanced')">AFq</th>
                        <th title="Won at Showdown %" onclick="renderStats('wsd', 'advanced')">WSD</th>
                        <th title="Went to Showdown %" onclick="renderStats('wtsd', 'advanced')">WTSD</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
            <button class="btn" style="background:#444; width:100%; margin-top:10px;" onclick="closeModal('modal-menu')">Back</button>
        </div>

        <div id="tab-history" class="tab-content">
             <div id="history-list"></div>
             <button class="btn" style="background:#444; width:100%; margin-top:10px;" onclick="closeModal('modal-menu')">Back</button>
        </div>
    </div>
</div>

            <div id="tab-history" class="tab-content">
                <div id="history-list"></div>
                // --- REPLACEMENT BLOCK: EXPORT/IMPORT CONTROLS ---
                <div style="display:flex; gap:10px; margin-top:15px;">
                    <button class="btn" style="background:var(--accent-green); flex:1;" onclick="exportSessionToExcel()">üìä Export Session Excel</button>
					<button class="btn" style="background:var(--accent-blue); flex:1;" onclick="saveSessionFile()">üíæ Save Game</button>
                </div>
                
                <button class="btn" style="background:#444; border:1px dashed #777; width:100%; margin-top:10px;" onclick="triggerLoadSession()">üìÇ Load Saved Game</button>
                
                <input type="file" id="file-input-session" style="display:none" accept=".json" onchange="loadSessionFile(this)">
                // ------------------------------------------------
                <button class="btn" style="background:#444; width:100%; margin-top:10px;" onclick="closeModal('modal-menu')">Back</button>
            </div>
        </div>
    </div>

    <div id="modal-cards" class="modal">
        <div class="modal-content">
            <h2 style="text-align:center; margin-bottom:10px;" id="card-modal-title">Select Cards</h2>
            
            <div id="modal-board-controls" class="modal-controls-row" style="display:none;">
                <select id="modal-street-select" class="modal-select" onchange="updateModalStreet()">
                    <option value="0">Preflop</option>
                    <option value="1">Flop</option>
                    <option value="2">Turn</option>
                    <option value="3">River</option>
                </select>
                <select id="modal-rimt-select" class="modal-select" onchange="updateModalRIMT()">
                    <option value="1">Run Once</option>
                    <option value="2">Run Twice</option>
                    <option value="3">Run 3 Times</option>
                    <option value="4">Run 4 Times</option>
                    <option value="5">Run 5 Times</option>
                </select>
            </div>

            <div id="rimt-modal-tabs" class="rimt-tabs" style="display:none;"></div>

            <div id="card-preview" style="display:flex; justify-content:center; gap:5px; margin-bottom:20px; min-height:40px;"></div>
            <div class="suit-grid"><button class="suit-btn" onclick="setSuit('s')" style="color:#aaa">‚ô†</button><button class="suit-btn" onclick="setSuit('h')" style="color:#f55">‚ô•</button><button class="suit-btn" onclick="setSuit('d')" style="color:#f55">‚ô¶</button><button class="suit-btn" onclick="setSuit('c')" style="color:#aaa">‚ô£</button></div>
            <div class="rank-grid" id="rank-grid"></div>
            <div style="margin-top:20px; display:flex; gap:10px;"><button class="btn-primary" onclick="confirmCards()">Save</button><button class="btn" style="background:#444; margin-top:10px;" onclick="closeModal('modal-cards')">Close</button><button class="btn" style="background:#666;" onclick="setMuckedHand()">MUCK [?,?]</button></div>
        </div>
    </div>

    <div id="modal-bet" class="modal">
        <div class="modal-content">
            <h2>Enter Total Bet</h2>
            <div style="font-size:12px; color:#888; text-align:center; margin-bottom:5px;">Current in front: <span id="current-bet-display" style="color:var(--accent-gold);">0</span></div>
            <div style="font-size:35px; text-align:center; margin:10px 0; border:1px solid #444; padding:5px; border-radius:5px;" id="bet-input-display">0</div>
            
            <div class="bet-adjust-row">
                <button class="btn-adjust" onclick="adjustBet(-1)" id="btn-dec">-</button>
                <button class="btn-adjust" onclick="adjustBet(1)" id="btn-inc">+</button>
            </div>

            <div class="num-pad">
                <button class="num-btn" onclick="numInput(1)">1</button><button class="num-btn" onclick="numInput(2)">2</button><button class="num-btn" onclick="numInput(3)">3</button>
                <button class="num-btn" onclick="numInput(4)">4</button><button class="num-btn" onclick="numInput(5)">5</button><button class="num-btn" onclick="numInput(6)">6</button>
                <button class="num-btn" onclick="numInput(7)">7</button><button class="num-btn" onclick="numInput(8)">8</button><button class="num-btn" onclick="numInput(9)">9</button>
                <button class="num-btn" onclick="numInput('.')">.</button><button class="num-btn" onclick="numInput(0)">0</button>
                <button class="num-btn btn-backspace" onclick="backspaceBet()">‚å´</button>
            </div>
            
            <button class="btn-primary" style="margin-top:10px;" onclick="confirmBet()">OK (Bet/Raise)</button>
<div style="display:flex; gap:10px; margin-top:10px;">
    <button class="btn" style="background:#444; flex:1" onclick="closeModal('modal-bet')">Cancel</button>
    <button class="btn" style="background:var(--accent-blue); flex:1" onclick="quickPotBet()">Pot</button>
    <button class="btn" style="background:var(--accent-red); flex:1; font-weight:bold;" onclick="handleSmartAllIn()">ALL IN</button>
</div>
            <div style="display:flex; gap:10px; margin-top:10px;"><button class="btn" style="background:#444; flex:1" onclick="closeModal('modal-bet')">Cancel</button><button class="btn" style="background:var(--accent-blue); flex:1" onclick="quickPotBet()">Pot</button></div>
        </div>
    </div>
	<script>
        // --- STATE ---
        // --- STATE ---
		
		// Initialize Database
const DB_NAME = 'PokerHistoryDB';
const DB_VERSION = 2; // Increased to 2 to ensure the new "No Auto-Increment" structure applies

const request = indexedDB.open(DB_NAME, DB_VERSION);

request.onupgradeneeded = (e) => {
    const db = e.target.result;
    // If an old version exists, delete it so we can create the correct structure
    if (db.objectStoreNames.contains('hands')) {
        db.deleteObjectStore('hands');
    }
    // Create the store: strict 'id' as key, NO auto-increment
    db.createObjectStore('hands', { keyPath: 'id' });
};

// Function to save hand to permanent storage
function saveHandToPermanentStorage(handData) {
    // Safety check: if there is no ID, we can't save it
    if (!handData || handData.id === undefined) {
        console.error("CRITICAL: Attempted to save hand without an ID!", handData);
        return;
    }

    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onsuccess = (e) => {
        const db = e.target.result;
        const tx = db.transaction('hands', 'readwrite');
        const store = tx.objectStore('hands');
        
        // This will now work because handData.id exists
        const saveRequest = store.put(handData);
        
        saveRequest.onerror = (err) => {
            console.error("IndexedDB Put Error:", err.target.error);
        };
    };
}
		
        let game = {
            players: [],
            sb: 0.2, bb: 0.4, ante: 0.1, minBuyin: 20, maxBuyin: 100, betIncrement: 0.25,
            dealerIndex: 0, pot: 0, handCount: 1, street: 0,
            
            boards: [[]], 
            runoutCount: 1,
            viewingBoardIndex: 0, 
            
            // Edit state for Modal
            editBoardIndex: 0, 
            workingBoards: [[]], 
            
            history: [], activePlayerIndex: -1,
            currentHandReplay: [], 
            replayIndex: 0, activeReplayHand: null,
            historyFilter: 'all', 
            tempBet: "0", isAddMode: false,
            tempCards: [], isSelectingBoard: false,
            
            standUpActive: false,
            nitSettings: { mode: 'splash', amount: 5, doubleNit: false, customMsg: "" },
            pendingSplash: 0,
            
            undoStack: [],
            turnStartTime: 0, accumulatedTime: 0, 
            shotClockTime: 0, isShotClockActive: false,
            currentStraddleAmt: 0, lastStraddleIdx: -1,
            paused: false,
            isBombPot: false, 
            bombPotAnte: 5,   
            gameMode: 'he',   
            sevenDeuceAmt: 1, 
            isShowdownEntry: false,
            autoWinner: false,
            preflopRaiseCount: 0,
            winnerTimeout: null,
            manualSBIndex: -1, manualBBIndex: -1,
            currentSBIndex: -1, currentBBIndex: -1,
            contextPlayerIdx: -1, handStartSnapshot: null,
            selectedManualWinners: []
        };

        // FIX: Sorting variables (These were missing or duplicated before)
        let sortColumn = { basic: 'profit', advanced: 'pfr' };
        let sortDirection = { basic: 1, advanced: 1 };

        const streets = ["PREFLOP", "FLOP", "TURN", "RIVER", "SHOWDOWN"];
        const suits = { 's': '‚ô†', 'h': '‚ô•', 'd': '‚ô¶', 'c': '‚ô£' };
        const ranks = ['A','K','Q','J','T','9','8','7','6','5','4','3','2','?'];
        let timerInterval, shotClockInterval;
        let holdTimer;

        // --- INIT ---
        document.addEventListener('DOMContentLoaded', () => { generatePlayerInputs(); });
        function generatePlayerInputs() {
            // FIX: Corrected ID to match the HTML <div id="player-inputs">
            const container = document.getElementById('player-inputs');
            container.innerHTML = "";
            const num = parseInt(document.getElementById('player-count').value);
            
            const customNames = ["Wayne", "Jan", "Zejz", "Glenn", "Julian", "Mattea"];
            
            for(let i=0; i<num; i++) {
                const div = document.createElement('div');
                div.className = "setup-row";
                
                const defaultName = customNames[i] || `Player ${i+1}`;
                
                // We use ids 'p-name-X' and 'p-stack-X' here
                div.innerHTML = `
                    <label>Player ${i+1}</label>
                    <input type="text" id="p-name-${i}" value="${defaultName}" class="setup-input">
                    <input type="number" id="p-stack-${i}" value="100" class="setup-input" placeholder="Stack">
                `;
                container.appendChild(div);
            }
        }
        
        function startGame() {
    game.lazyMode = setupCasualActive;
    game.sb = parseFloat(document.getElementById('sb-amount').value);
    game.bb = parseFloat(document.getElementById('bb-amount').value);
    game.ante = parseFloat(document.getElementById('ante-amount').value);
    game.betIncrement = parseFloat(document.getElementById('bet-increment').value) || 0.25;
    game.minBuyin = parseFloat(document.getElementById('min-buyin').value) || 20;
    game.maxBuyin = parseFloat(document.getElementById('max-buyin').value) || 100;
    
    document.getElementById('btn-inc').innerText = "+" + game.betIncrement;
    document.getElementById('btn-dec').innerText = "-" + game.betIncrement;

    const count = parseInt(document.getElementById('player-count').value);
    game.players = [];

    // --- CRITICAL FIX: Initialize Undo System ---
    game.undoStack = [];
    game.redoStack = [];

    if(!document.getElementById(`p-name-0`)) return generatePlayerInputs();

    for(let i=0; i<count; i++) {
        const stackInput = document.getElementById(`p-stack-${i}`);
        const nameInput = document.getElementById(`p-name-${i}`);
        const stack = parseFloat(stackInput.value);
        
        game.players.push({
            name: nameInput.value,
            stack: stack, 
            buyInTotal: stack, // This is the INITIAL Buy-in
            rebuyTotal: 0,     // Initialized to 0
            rebuyCount: 0,     // Initialized to 0
            folded: false, 
            sittingOut: false, 
            isStanding: false, 
            nitCharges: 0, 
            isOnBreak: false,
            cards: [], 
            currentBet: 0, 
            hasActed: false, 
            isChecked: false, 
            lastAction: "",
            
            // Stats
            totalHands: 0, vpipHands: 0, vpipThisHand: false,
            totalTime: 0, totalDecisions: 0, nitCount: 0, sevenDeuceWins: 0, bombPotWins: 0,
            
            // Advanced Stats
            pfrHands: 0, hasPFRThisHand: false,
            threeBetHands: 0,
            postFlopAggressiveActions: 0,
            postFlopOpportunities: 0,
            showdownHands: 0, showdownWins: 0,
            winWithoutShowdown: 0,
            casualCorrection: 0 // Safety for the "Ghost Ledger"
        });
    }
    document.getElementById('view-setup').classList.remove('active');
    document.getElementById('view-game').classList.add('active');
    newHand();
    startGlobalTimer();
}
		
		function backToHistory() {
    document.getElementById('modal-replay').classList.remove('open');
    document.getElementById('modal-menu').classList.add('open');
    
    // Clear temporary memory
    game.activeReplayHand = null;
    game.currentVisibleReplayDoc = null;
}

        // --- NIT LOGIC ---
        function openNitSettings() {
            const s = game.nitSettings;
            const swActive = document.getElementById('sw-nit-active');
            if(game.standUpActive) swActive.classList.add('on'); else swActive.classList.remove('on');

            const swDouble = document.getElementById('sw-double-nit');
            if(s.doubleNit) swDouble.classList.add('on'); else swDouble.classList.remove('on');
            
            setNitMode(s.mode); 
            document.getElementById('nit-penalty-amount').value = s.amount || 5;
            document.getElementById('nit-custom-msg').value = s.customMsg || "";
            
            closeModal('modal-menu');
            document.getElementById('modal-nit-settings').classList.add('open');
        }

        function toggleNitSetting(key) {
            if(key === 'double') {
                game.nitSettings.doubleNit = !game.nitSettings.doubleNit;
                const sw = document.getElementById('sw-double-nit');
                if(game.nitSettings.doubleNit) sw.classList.add('on'); else sw.classList.remove('on');
            } else if (key === 'active') {
                game.standUpActive = !game.standUpActive;
                const sw = document.getElementById('sw-nit-active');
                if(game.standUpActive) sw.classList.add('on'); else sw.classList.remove('on');
            }
        }

        function setNitMode(mode) {
            game.nitSettings.mode = mode;
            document.getElementById('btn-mode-splash').style.background = mode === 'splash' ? 'var(--accent-green)' : '#444';
            document.getElementById('btn-mode-splash').style.color = mode === 'splash' ? 'black' : 'white';
            document.getElementById('btn-mode-pay').style.background = mode === 'pay' ? 'var(--accent-blue)' : '#444';
        }

        function saveNitSettings() {
            const amt = parseFloat(document.getElementById('nit-penalty-amount').value);
            if(isNaN(amt) || amt < 0) return alert("Invalid Amount");
            game.nitSettings.amount = amt;
            game.nitSettings.customMsg = document.getElementById('nit-custom-msg').value.trim();
            
            if(game.standUpActive) {
                const charges = game.nitSettings.doubleNit ? 2 : 1;
                game.players.forEach(p => {
                    if(!p.sittingOut && !p.isOnBreak) {
                        p.isStanding = true;
                        if(p.nitCharges === 0) p.nitCharges = charges;
                    } else {
                        p.isStanding = false;
                        p.nitCharges = 0;
                    }
                });
            } else {
                game.players.forEach(p => { p.isStanding = false; p.nitCharges = 0; });
            }
            closeModal('modal-nit-settings');
            openMenuModal(); 
            renderTable();
        }

        function checkNitWinner(winner) {
            if(!game.standUpActive) return;
            if(winner && winner.nitCharges > 0) {
                winner.nitCharges--;
                if(winner.nitCharges === 0) winner.isStanding = false;
            }
            const playersWithButtons = game.players.filter(p => p.nitCharges > 0 && !p.sittingOut && !p.isOnBreak);
            if(playersWithButtons.length === 1) { resolveNitLoser(playersWithButtons[0]); }
        }

        function resolveNitLoser(loser) {
            const amt = game.nitSettings.amount;
            const custom = game.nitSettings.customMsg;
            loser.nitCount++;
            let consequence = "";
            if(game.nitSettings.mode === 'splash') {
                loser.stack -= amt; game.pendingSplash += amt; consequence = `Splashes ${formatMoney(amt)} next hand!`;
            } else {
                const others = game.players.filter(p => !p.sittingOut && p !== loser);
                let totalDeduction = 0;
                others.forEach(o => { o.stack += amt; totalDeduction += amt; });
                loser.stack -= totalDeduction; consequence = `Pays ${formatMoney(amt)} to everyone!`;
            }
            let titleLine = custom ? `${loser.name} ${custom}` : `${loser.name} loses the Nit Game!`;
            let finalMsg = `${titleLine}<br>${consequence}`;
            
            game.standUpActive = false;
            // FIX: Don't wipe nitCharges yet! Wait for history to save first.
            game.players.forEach(p => { p.isStanding = false; }); 
            
            document.getElementById('nit-loser-msg').innerHTML = finalMsg + "<br>ü§°";
            document.getElementById('nit-overlay').classList.add('visible');
            renderTable();
        }

        // --- TURN LOGIC & TIMERS ---
        function startTurnTimer() { game.turnStartTime = Date.now(); game.accumulatedTime = 0; }
        function stopTurnTimer() {
             if(game.activePlayerIndex !== -1) {
                 let currentSegment = 0;
                 if (!game.paused) currentSegment = Date.now() - game.turnStartTime;
                 const totalElapsed = game.accumulatedTime + currentSegment;
                 const p = game.players[game.activePlayerIndex];
                 p.totalTime += totalElapsed; p.totalDecisions++;
             }
        }
        function startGlobalTimer() {
            if(timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if(!game.paused && game.activePlayerIndex > -1 && !game.isShowdownEntry) {
                    const el = document.getElementById(`timer-${game.activePlayerIndex}`);
                    if(el) { 
                        const currentSegment = Date.now() - game.turnStartTime;
                        const totalMs = game.accumulatedTime + currentSegment;
                        el.innerText = Math.floor(totalMs/1000) + 's'; 
                    }
                }
            }, 500); 
        }
		function toggleLiveFavorite() {
            game.currentHandFavorite = !game.currentHandFavorite;
            const btn = document.getElementById('live-fav-btn');
            if(game.currentHandFavorite) {
                btn.innerText = "‚òÖ";
                btn.style.color = "var(--accent-gold)";
            } else {
                btn.innerText = "‚òÜ";
                btn.style.color = "#aaa";
            }
        }
        function togglePause() { 
            game.paused = !game.paused; 
            if (game.paused) {
                if (game.activePlayerIndex > -1) game.accumulatedTime += (Date.now() - game.turnStartTime);
            } else {
                game.turnStartTime = Date.now();
            }
            document.getElementById('pause-overlay').classList.toggle('visible', game.paused); 
            const btn = document.getElementById('main-pause-btn');
            btn.innerText = game.paused ? "‚ñ∂" : "‚è∏";
        }

        // --- CONTEXT MENU ---
        function handleTouchStart(e, i) { holdTimer = setTimeout(() => { openContextMenu(e, i); }, 600); }
        function handleTouchEnd() { clearTimeout(holdTimer); }
        function openContextMenu(e, i) {
            e.preventDefault(); game.contextPlayerIdx = i;
            const menu = document.getElementById('context-menu');
            let x = e.clientX || (e.touches && e.touches[0].clientX);
            let y = e.clientY || (e.touches && e.touches[0].clientY);
            if (x + 150 > window.innerWidth) x = window.innerWidth - 160;
            if (y + 150 > window.innerHeight) y = window.innerHeight - 160;
            menu.style.left = x + 'px'; menu.style.top = y + 'px'; menu.classList.add('open');
        }
        function hideContextMenu() { document.getElementById('context-menu').classList.remove('open'); }

        // --- BLIND REFUND & CHARGE HELPERS ---
        function refundBlind(playerIdx, amount) {
            if(playerIdx === -1 || !game.players[playerIdx]) return;
            const p = game.players[playerIdx];
            const refundAmt = Math.min(p.currentBet, amount);
            if(refundAmt > 0) {
                p.stack += refundAmt; p.currentBet -= refundAmt; game.pot -= refundAmt;
                p.stack = Math.round(p.stack * 100) / 100; p.currentBet = Math.round(p.currentBet * 100) / 100; game.pot = Math.round(game.pot * 100) / 100;
                saveReplayStep(`Correction: Refunded ${formatMoney(refundAmt)} to ${p.name}`);
            }
        }
        function chargeBlind(playerIdx, amount) {
    if(playerIdx === -1 || !game.players[playerIdx]) return;
    const p = game.players[playerIdx];

    // FIX: Calculate 'charge' based on the game mode
    let charge = 0;
    
    if (game.lazyMode) {
        // Casual Mode: ALWAYS charge the full amount, even if stack is negative.
        charge = amount;
    } else {
        // Normal Mode: Cannot bet more than you have.
        // We use Math.max(0, p.stack) to ensure we don't get a negative charge if stack is already < 0 error.
        charge = Math.min(Math.max(0, p.stack), amount);
    }

    if(charge > 0) {
        p.stack -= charge; 
        p.currentBet += charge; 
        game.pot += charge;
        
        // Rounding fixes
        p.stack = Math.round(p.stack * 100) / 100; 
        p.currentBet = Math.round(p.currentBet * 100) / 100; 
        game.pot = Math.round(game.pot * 100) / 100;
        
        saveReplayStep(`Correction: Posted ${formatMoney(charge)} blind for ${p.name}`);
    }
}
        function setManualRole(role) {
            if (game.contextPlayerIdx === -1) return;
            const targetIdx = game.contextPlayerIdx;
            const isPreFlop = game.street === 0;
            
            if (role === 'dealer') {
                if(game.street === 0 && game.handStartSnapshot) {
                    if(confirm("Changing dealer pre-flop will RESTART the hand. Refund bets and deal again?")) {
                         game.players = JSON.parse(JSON.stringify(game.handStartSnapshot));
                         game.dealerIndex = game.contextPlayerIdx; game.manualSBIndex = -1; game.manualBBIndex = -1;
                         startHandLogic(); renderTable(); return;
                    }
                }
                game.dealerIndex = game.contextPlayerIdx; calculateBlindsForCurrentDealer(); renderTable();
            } else if (role === 'sb') {
                if (isPreFlop && game.currentSBIndex !== -1 && game.currentSBIndex !== targetIdx) { refundBlind(game.currentSBIndex, game.sb); }
                game.manualSBIndex = targetIdx; game.currentSBIndex = targetIdx;
                if (isPreFlop) chargeBlind(targetIdx, game.sb); renderTable();
            } else if (role === 'bb') {
                if (isPreFlop && game.currentBBIndex !== -1 && game.currentBBIndex !== targetIdx) { refundBlind(game.currentBBIndex, game.bb); }
                game.manualBBIndex = targetIdx; game.currentBBIndex = targetIdx;
                if (isPreFlop) chargeBlind(targetIdx, game.bb); renderTable();
            } else if (role === 'clear') {
                if (game.currentSBIndex === targetIdx) {
                    if (isPreFlop) refundBlind(targetIdx, game.sb);
                    game.manualSBIndex = -1; game.currentSBIndex = -1;
                }
                if (game.currentBBIndex === targetIdx) {
                    if (isPreFlop) refundBlind(targetIdx, game.bb);
                    game.manualBBIndex = -1; game.currentBBIndex = -1;
                }
                renderTable();
            }
        }
        
        function calculateBlindsForCurrentDealer() {
            let sbI = -1;
            if (game.manualSBIndex !== -1 && !game.players[game.manualSBIndex].sittingOut) sbI = game.manualSBIndex;
            else sbI = getNextActive(game.dealerIndex + 1);

            let bbI = -1;
            if (game.manualBBIndex !== -1 && !game.players[game.manualBBIndex].sittingOut) bbI = game.manualBBIndex;
            else {
                const activeCount = game.players.filter(p => !p.sittingOut && !p.isOnBreak).length;
                if (activeCount === 2) { sbI = game.dealerIndex; bbI = getNextActive(sbI + 1); } 
                else { bbI = getNextActive(sbI + 1); }
            }
            game.currentSBIndex = sbI; game.currentBBIndex = bbI;
        }

        function renderTable() {
    const grid = document.getElementById('table-grid');

    // NEW: Auto-detect if we need "Dense Mode" (More than 8 players)
    if (game.players.length > 8) {
        grid.classList.add('dense-mode');
    } else {
        grid.classList.remove('dense-mode');
    }
    grid.innerHTML = "";

    // 1. CALL BUTTON LOGIC
    let maxBet = 0;
    game.players.forEach(p => maxBet = Math.max(maxBet, p.currentBet));
    if (game.activePlayerIndex !== -1) {
        const toCall = maxBet - game.players[game.activePlayerIndex].currentBet;
        document.getElementById('btn-call').innerText = toCall > 0 ? `CALL ${formatMoney(toCall)}` : "CHECK";
    }

    // --- 2. SIDE POT VISUAL CALCULATION ---
    const pots = calculatePotStructure();
    const playerPotColor = {};

    // Iterate BACKWARDS from Highest Side Pot -> Main Pot.
    for (let i = pots.length - 1; i >= 0; i--) {
        const pot = pots[i];
        pot.eligible.forEach(p => {
            const pIdx = game.players.indexOf(p);
            // Only color if they are All-In (stack is effectively 0)
            if (Math.abs(p.stack) < 0.01 && !p.folded && !p.sittingOut) {
                if (!playerPotColor[pIdx]) {
                    playerPotColor[pIdx] = pot.colorClass;
                }
            }
        });
    }

    // 3. RENDER PLAYERS
    game.players.forEach((p, i) => {
        let cardClasses = "";

        // Apply Pot Color Border if All-In
        const potColor = playerPotColor[i];
        if (potColor) {
            cardClasses += `style="border-color: ${potColor}; box-shadow: 0 0 10px ${potColor}80;"`;
        }

        const div = document.createElement('div');
        div.className = `player-card ${game.activePlayerIndex === i ? 'active-turn' : ''} ${p.folded ? 'folded' : ''} ${p.sittingOut ? 'sitting-out' : ''} ${p.isOnBreak ? 'on-break' : ''} ${p.isChecked ? 'checked' : ''} ${p.isStanding && game.standUpActive ? 'standing' : ''}`;
        
        if (potColor) div.setAttribute('style', `border-color: ${potColor}; box-shadow: 0 0 10px ${potColor}80;`);

        div.oncontextmenu = (e) => { openContextMenu(e, i); return false; };
        div.ontouchstart = (e) => handleTouchStart(e, i);
        div.ontouchend = handleTouchEnd;
        div.onclick = () => selectPlayer(i);

        // Card Logic
        let cardsHtml = "";
        if (p.folded || p.sittingOut || p.isOnBreak) {
            cardsHtml = "";
        } else if (game.street === 4 && p.cards && p.cards.length) {
            p.cards.forEach(c => cardsHtml += createCardHTML(c));
        } else {
            if (game.gameMode === 'plo' || game.isBombPot) {
                cardsHtml = createCardBackHTML() + createCardBackHTML() + createCardBackHTML() + createCardBackHTML();
            } else {
                cardsHtml = createCardBackHTML() + createCardBackHTML();
            }
        }

        // Nit Logic
        let nitHtml = "";
        if (p.nitCharges > 0) {
            nitHtml = `<div class="nit-container">`;
            for (let n = 0; n < p.nitCharges; n++) nitHtml += `<div class="nit-chip">NIT</div>`;
            nitHtml += `</div>`;
        }

        // --- NEW FEATURE: PERMANENT ALL-IN BADGE ---
        let allInBadgeHtml = "";
        if (Math.abs(p.stack) < 0.01 && !p.folded && !p.sittingOut && (p.handTotalBet > 0)) {
            allInBadgeHtml = `
                <div style="
                    background: var(--accent-red); 
                    color: white; 
                    font-size: 10px; 
                    font-weight: bold; 
                    text-align: center; 
                    border-radius: 4px; 
                    padding: 2px 4px; 
                    margin-top: 4px;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.5);
                ">
                    ALL IN: ${formatMoney(p.handTotalBet)}
                </div>
            `;
        }

        // ----------------------------------------------------
        // CASUAL MODE DISPLAY (TOGGLE FIX)
        // ----------------------------------------------------
        let stackDisplay = `‚Ç¨${formatMoney(p.stack)}`;
        
        if (game.lazyMode) {
             const textColor = p.stack < 0 ? "#ff5555" : "#2ecc71";
             
             // If not All-In (Zero)
             if (Math.abs(p.stack) > 0.01) {
                 // FIX: Added 'margin-right: 5px' to push it left slightly.
                 // FIX: Onclick now checks 'innerText'. If '‚Ç¨', show money. If money, show '‚Ç¨'.
                 stackDisplay = `<span 
                     style="color:${textColor}; cursor:pointer; font-size:18px; font-weight:bold; padding:0 8px; margin-right:5px; display:inline-block;" 
                     onclick="
                        const isSymbol = this.innerText.trim() === '‚Ç¨';
                        this.innerText = isSymbol ? '‚Ç¨${formatMoney(p.stack)}' : '‚Ç¨';
                        this.style.fontSize = isSymbol ? '14px' : '18px'; 
                        event.stopPropagation();
                     "
                     title="Tap to reveal/hide">
                     ‚Ç¨
                 </span>`;
             } else {
                 stackDisplay = `<span style="color:var(--accent-red); font-size:10px; font-weight:bold;">ALL IN</span>`;
             }
        }
        // ----------------------------------------------------

        div.innerHTML = `
            ${i === game.dealerIndex ? '<div class="role-btn dealer-btn">D</div>' : ''}
            ${i === game.currentSBIndex ? '<div class="role-btn sb-btn">SB</div>' : ''}
            ${i === game.currentBBIndex ? '<div class="role-btn bb-btn">BB</div>' : ''}
            ${nitHtml}
            ${p.isOnBreak ? '<div class="break-badge">ON BREAK</div>' : ''}
            <div class="p-name">${p.name}</div>
            
            <div class="p-stack">${stackDisplay}</div>
            
            <div class="p-action">${p.lastAction}</div>
            ${allInBadgeHtml} 
            <div class="p-cards">${cardsHtml}</div>
            <div class="p-timer" id="timer-${i}">${game.activePlayerIndex === i ? Math.floor(game.accumulatedTime / 1000) + 's' : ''}</div>
        `;
        grid.appendChild(div);
    });

    // 4. RENDER BOARD
    const bArea = document.getElementById('board-area');
    bArea.innerHTML = "";
    let hasAnyCards = false;
    for (let r = 0; r < game.runoutCount; r++) {
        const currentBoard = game.boards[r] || [];
        if (currentBoard.length > 0) {
            hasAnyCards = true;
            let h = "";
            currentBoard.forEach(c => h += createCardHTML(c));

            const runContainer = document.createElement('div');
            runContainer.className = 'runout-container';
            if (game.runoutCount > 1) {
                runContainer.innerHTML = `<div class="runout-label">Run ${r + 1}</div><div class="board-cards-container">${h}</div>`;
            } else {
                runContainer.innerHTML = `<div class="board-cards-container">${h}</div>`;
            }
            bArea.appendChild(runContainer);
        }
    }
    if (!hasAnyCards) {
        bArea.innerHTML = `<span style="color:#555; font-size:12px; align-self:center;">(Tap for Board)</span>`;
    }

    // 5. INSTANT POT VISUAL + SIDE POT DISPLAY
    let currentBetsOnTable = 0;
    game.players.forEach(p => { if (p.currentBet > 0) currentBetsOnTable += p.currentBet; });
    const visualPot = game.pot + currentBetsOnTable;

    const potEl = document.getElementById('pot-amount');
    const visiblePots = pots.filter(p => p.amount > 0.01);

    if (visiblePots.length > 1) {
        let html = `<span style="font-size:22px;">${formatMoney(visualPot)}</span>`;
        html += `<div style="font-size:11px; margin-top:2px;">`;

        visiblePots.forEach((p, i) => {
            html += `<span style="color:${p.colorClass}; font-weight:bold;">${p.name}: ${formatMoney(p.amount)}</span>`;
            if (i < visiblePots.length - 1) html += " | ";
        });
        html += `</div>`;
        potEl.innerHTML = html;
    } else {
        potEl.innerHTML = `<span style="color:var(--accent-green);">${formatMoney(visualPot)}</span>`;
    }

    document.getElementById('street-name').innerText = streets[game.street];
    document.getElementById('hand-number').innerText = game.handCount;
    saveLocal();
}

        // NEW HELPER FOR CARD BACKS
        function createCardBackHTML(isMini=false) {
             return `<div class="card-visual back ${isMini ? 'small' : ''}"></div>`;
        }

        function createCardHTML(c) {
            if(!c) return "";
            const suit = c.slice(-1); const rank = c.slice(0, -1);
			// --- NEW: Handle Mystery Card ---
			if (rank === '?') {
				// Render a grey card with a '?'
				let sizeClass = ""; // handle size if needed
				return `<div class="card-visual ${sizeClass}" style="color:#888; border:1px solid #666; background:#2a2a2a;">?</div>`;
			}
            let colorClass = '';
            if(suit === 'd') colorClass = 'blue'; if(suit === 'h') colorClass = 'red'; if(suit === 'c') colorClass = 'green';
            return `<div class="card-visual ${colorClass}">${rank}${suits[suit]}</div>`;
        }
        function createMiniCardHTML(c) {
             if(!c) return "";
             const suit = c.slice(-1); const rank = c.slice(0, -1);
			 // --- NEW: Handle Mystery Card ---
			if (rank === '?') {
				// Render a grey card with a '?'
				let sizeClass = ""; // handle size if needed
				return `<div class="card-visual ${sizeClass}" style="color:#888; border:1px solid #666; background:#2a2a2a;">?</div>`;
			}
             let colorClass = '';
             if(suit === 'd') colorClass = 'blue'; if(suit === 'h') colorClass = 'red'; if(suit === 'c') colorClass = 'green';
             return `<div class="card-visual small ${colorClass}">${rank}${suits[suit]}</div>`;
        }
		function newHand() {
			// --- STRADDLE RESET ---
			if (game.pot > 0) {
        console.warn("Cannot start new hand: Current hand still in progress.");
        return;
    }
			game.lastStraddleIdx = -1;
			game.straddleOptionUsed = false;
			game.currentStraddleAmt = 0;
			// ----------------------
			game.isBombPot = false;
			game.gameMode = 'he';
            game.manualSBIndex = -1; game.manualBBIndex = -1;
            game.dealerIndex = (game.dealerIndex + 1) % game.players.length;
            let safety = 0;
            while ((game.players[game.dealerIndex].sittingOut || game.players[game.dealerIndex].isOnBreak) && safety < game.players.length) {
                game.dealerIndex = (game.dealerIndex + 1) % game.players.length;
                safety++;
            }
            startHandLogic();
        }
        
        function startHandLogic() {
    // Reset hand-specific flags
    game.currentHandFavorite = false; 
    const favBtn = document.getElementById('live-fav-btn');
    if(favBtn) { favBtn.innerText = "‚òÜ"; favBtn.style.color = "#aaa"; }
    
    game.players.forEach(p => {
        p.folded = p.sittingOut || p.isOnBreak; 
        p.cards = []; 
        p.currentBet = 0; 
        p.hasActed = false; 
        p.isChecked = false; 
        p.lastAction = ""; 
        
        // --- FIX 1: RESET THE CORRECT NEW FLAGS ---
        // We must reset the flags used in the new system
        p.hasVPIP = false; 
        p.hasPFR = false; 
        p.has3Bet = false; 
        
        // Legacy flags (keep just in case other parts of code use them)
        p.vpipThisHand = false; 
        p.hasPFRThisHand = false; 
        
        // IMPORTANT: Reset Side Pot Tracker
        p.handTotalBet = 0;

        // --- FIX 2: SAFE INCREMENT ---
        // p.totalHands++ results in NaN if undefined. This fixes it.
        if(!p.sittingOut && !p.isOnBreak) { 
            p.totalHands = (p.totalHands || 0) + 1; 
        }

        if (!game.standUpActive) { p.nitCharges = 0; }
    });

    game.handStartSnapshot = JSON.parse(JSON.stringify(game.players));
    calculateBlindsForCurrentDealer();
    let sbI = game.currentSBIndex; let bbI = game.currentBBIndex;

    game.pot = 0; game.street = 0; 
    game.boards = [[]]; 
    game.runoutCount = 1; 
    game.viewingBoardIndex = 0;
    
    game.activePlayerIndex = -1;
    game.currentHandReplay = []; 
    
    game.currentStraddleAmt = 0; game.lastStraddleIdx = -1;
    game.isShowdownEntry = false; game.preflopRaiseCount = 0;
    
    const nb = document.getElementById('btn-next');
    if(nb) { nb.innerText = "NEXT"; nb.classList.remove('btn-showdown'); }

    let activeCnt = game.players.filter(p => !p.sittingOut && !p.isOnBreak).length;
    if(activeCnt < 2) return;

    saveReplayStep("Hand Started");

    // --- Splash Logic ---
    if(game.pendingSplash > 0) {
        game.pot += game.pendingSplash;
        saveReplayStep(`Nit Penalty Added: ${formatMoney(game.pendingSplash)}`);
        game.pendingSplash = 0;
    }

    // --- Ante Logic (FIXED) ---
    if(game.ante > 0) {
        game.players.forEach(p => { 
            // FIX: Removed 'p.stack > 0' check so negative stacks still pay ante
            if(!p.sittingOut && !p.isOnBreak) {
                let amt = 0;
                if(game.lazyMode) {
                    amt = game.ante; // Always pay full ante in Casual Mode
                } else {
                    // Normal Mode: Pay what you can (max of 0 to avoid negative math errors)
                    amt = Math.min(Math.max(0, p.stack), game.ante);
                }

                if(amt > 0) {
                    // FIX: Ensure precision when deducting ante
                    p.stack = parseFloat((p.stack - amt).toFixed(2)); 
                    game.pot = parseFloat((game.pot + amt).toFixed(2));
                    p.handTotalBet += amt; 
                }
            }
        });
        saveReplayStep("Antes Posted");
    }
    
    // --- Blind Logic (FIXED) ---
    if (sbI > -1 && game.currentSBIndex > -1) { 
        const p = game.players[sbI];
        // FIX: If Casual Mode, force full amount. If Normal, calculate safe max.
        let amt = game.lazyMode ? game.sb : Math.min(Math.max(0, p.stack), game.sb);
        placeBetLogic(sbI, amt, true); 
        p.hasActed = false; 
    }

    if (bbI > -1 && game.currentBBIndex > -1) { 
        const p = game.players[bbI];
        // FIX: Same fix for BB
        let amt = game.lazyMode ? game.bb : Math.min(Math.max(0, p.stack), game.bb);
        placeBetLogic(bbI, amt, true); 
        p.hasActed = false; 
    }

    // --- Determine First Active Player (UTG) ---
    // FIX: Manually find next player to ensure negative stacks aren't skipped
    let nextIdx = -1;
    const n = game.players.length;
    // Start searching from player after Big Blind
    let startSearch = (bbI + 1) % n;
    
    for(let i=0; i<n; i++) {
         const idx = (startSearch + i) % n;
         const p = game.players[idx];
         if(!p.folded && !p.sittingOut && !p.isOnBreak) {
             // Check if they have chips (positive or negative)
             if(Math.abs(p.stack) > 0.01) {
                 nextIdx = idx;
                 break;
             }
         }
    }
    game.activePlayerIndex = nextIdx;
    
    startTurnTimer(); 
    renderTable();
}

        // --- TURN LOGIC ---
        function getNextActive(start) {
            let idx = start % game.players.length; 
            let count = 0;
            // FIX: Added check for (p.stack === 0) to skip All-In players
            while(
                (game.players[idx].sittingOut || 
                 game.players[idx].folded || 
                 game.players[idx].isOnBreak || 
                 game.players[idx].stack === 0) 
                && count < game.players.length * 2
            ) { 
                idx = (idx + 1) % game.players.length; 
                count++; 
            }
            
            // Safety: If everyone is all in, just return -1 to signal no actions left
            if (count >= game.players.length * 2) return -1;
            
            return idx;
        }

       function advanceTurn() {
    // 1. Define who is in the hand
    const active = game.players.filter(p => !p.folded && !p.sittingOut && !p.isOnBreak);
    
    // Casual/Lazy Mode Fix: Treat any non-zero stack (positive OR negative) as having chips.
    const activeWithChips = active.filter(p => Math.abs(p.stack) > 0.01);
    
    // Determine if everyone has acted. 
    // Logic: Everyone has acted OR they have effectively 0 chips (All-In).
    // Note: Negative stack players count as having chips, so they MUST act.
    const allActed = active.every(p => p.hasActed || (Math.abs(p.stack) < 0.01));
    
    let max = 0; active.forEach(p => max = Math.max(max, p.currentBet));
    
    // Matched logic: Current bet equals max OR they are All-In (0 chips)
    const matched = active.every(p => p.currentBet === max || (Math.abs(p.stack) < 0.01));
    
    // 1. Win Without Showdown (Everyone else folded)
    if(active.length === 1) {
        pushUndoState(); 
        returnUncalledBets(); 
        const w = active[0]; 
        let totalPotCollected = game.pot;
        game.players.forEach(p => { totalPotCollected += p.currentBet; p.currentBet = 0; });
        totalPotCollected = parseFloat(totalPotCollected.toFixed(2));
        w.stack = parseFloat((w.stack + totalPotCollected).toFixed(2));
        w.winWithoutShowdown++;
        checkNitWinner(w);
        finishHand([{ name: w.name, amt: totalPotCollected, hand: "Win (No Showdown)" }]);
        return;
    }

    // 2. Logic for "Betting Finished" (Move to next street)
    if(allActed && matched) {
        
        // --- Straddle Option Logic ---
        if (game.street === 0 && game.currentStraddleAmt > 0) {
            let highestBet = 0;
            game.players.forEach(p => { if(p.currentBet > highestBet) highestBet = p.currentBet; });

            if (Math.abs(highestBet - game.currentStraddleAmt) < 0.01) {
                const straddler = game.players[game.lastStraddleIdx];
                if (straddler && Math.abs(straddler.stack) > 0.01 && straddler.lastAction.includes("STRAD")) {
                     game.activePlayerIndex = game.lastStraddleIdx;
                     straddler.hasActed = false; 
                     renderTable();
                     startTurnTimer();
                     return; 
                }
            }
        }

        // Jump to Showdown or Next Street
        if (game.street === 3 || activeWithChips.length <= 1) {
            if (activeWithChips.length <= 1 && game.street < 3) {
                 while(game.street < 3) { game.street++; }
                 let boardsOk = true;
                 for(let i=0; i<game.runoutCount; i++) if(!game.boards[i] || game.boards[i].length<5) boardsOk = false;
                 
                 if(!boardsOk) {
                     game.activePlayerIndex = -1;
                     alert("Players are All-In. Please enter all Board Cards.");
                     openBoardSelector();
                     return;
                 }
            }
            returnUncalledBets(); 
            nextStreet(); 
            game.activePlayerIndex = -1;
            const nb = document.getElementById('btn-next');
            if(nb) { nb.innerText = "SHOWDOWN"; nb.classList.add('btn-showdown'); }
            renderTable(); 
            return;
        } 
        
        // Normal Street Transition
        if (active.length > 1 && game.street < 3) {
            returnUncalledBets(); 
            renderTable(); 
            setTimeout(nextStreet, 500);
        } else {
             game.activePlayerIndex = -1; 
             renderTable();
        }

    } else {
        // 3. Move to next player
        let nextIndex = -1;
        const n = game.players.length;
        
        // Search forward from current player
        for (let i = 1; i < n; i++) {
            const idx = (game.activePlayerIndex + i) % n;
            const p = game.players[idx];
            
            if (p.folded || p.sittingOut || p.isOnBreak) continue;

            // FIX: Ensure negative stacks are seen as "Having Chips"
            const hasChips = Math.abs(p.stack) > 0.01;

            if (hasChips) {
                nextIndex = idx;
                break;
            }
        }

        if (nextIndex === -1) {
            renderTable(); setTimeout(nextStreet, 500);
        } else {
            game.activePlayerIndex = nextIndex; 
            startTurnTimer(); 
            renderTable();
        }
    }
}
        
        function validateBoardState() {
            for(let i=0; i<game.runoutCount; i++) {
                 const b = game.boards[i] || [];
                 if(game.street === 1 && b.length < 3) return false;
                 if(game.street === 2 && b.length < 4) return false;
                 if(game.street === 3 && b.length < 5) return false;
            }
            return true;
        }

		function nextStreet() {
    // FIX: If we are already at Showdown (Street 4), just re-trigger the entry logic
    if (game.street === 4) {
        startShowdownEntry();
        return;
    }

    if(game.street < 4) {
        pushUndoState();
        
        // 1. Return Uncalled Bets first
        returnUncalledBets();

        // 2. Clear Bets & Reset Actions
        game.players.forEach(p => {
            p.currentBet = 0; 
            
            // FIX: Reset flags for everyone involved in the hand, even if stack is negative.
            // Old code checked (p.stack > 0) which broke Casual Mode.
            if (!p.folded && !p.sittingOut) {
                p.hasActed = false; 
                p.isChecked = false; 
                p.lastAction = ""; 
            }
        });
        
        // 3. Recalculate Pot
        game.pot = recalculateGlobalPot();
        
        saveReplayStep(`Bets Collected (Pot: ${formatMoney(game.pot)})`);

        game.street++;
        game.preflopRaiseCount = 0;
        
        if(game.street === 4) {
            game.activePlayerIndex = -1; 
            const nb = document.getElementById('btn-next');
            if(nb) { nb.innerText = "SHOWDOWN"; nb.classList.add('btn-showdown'); }
            startShowdownEntry();
        } else {
            // FIX: Manually calculate first active player to ensure negative stacks are caught.
            // (Standard getNextActive might still be checking > 0).
            let nextIdx = -1;
            const n = game.players.length;
            for(let i=1; i<n; i++) {
                 // Start searching left of dealer
                 const idx = (game.dealerIndex + i) % n;
                 const p = game.players[idx];
                 if(!p.folded && !p.sittingOut && !p.isOnBreak) {
                     // Check if they have "chips" (positive or negative)
                     if(Math.abs(p.stack) > 0.01) {
                         nextIdx = idx;
                         break;
                     }
                 }
            }
            game.activePlayerIndex = nextIdx;

            saveReplayStep(`--- ${streets[game.street]} ---`);
            
            if(game.street <= 3) {
                 renderTable(); 
                 // Small delay to let table render before opening board selector
                 setTimeout(() => openBoardSelector(), 300);
            } else {
                 startTurnTimer(); 
                 renderTable();
            }
        }
    }
}

        function startShowdownEntry() {
    // 1. Check for active players who haven't entered cards yet
    const idx = game.players.findIndex(p => !p.folded && !p.sittingOut && !p.isOnBreak && p.cards.length === 0);

    if (idx !== -1) {
        // Found a player missing cards -> Force Entry
        game.isShowdownEntry = true;
        game.activePlayerIndex = idx;
        renderTable();
        // Small delay to allow UI to render before popup
        setTimeout(openHandSelector, 100);
    } else {
        // Everyone has cards
        game.isShowdownEntry = false;
        game.activePlayerIndex = -1;
        renderTable();

        // 2. Check if boards are fully populated
        let boardsReady = true;
        for (let i = 0; i < game.runoutCount; i++) {
            if (!game.boards[i] || game.boards[i].length < 5) boardsReady = false;
        }

        // 3. Determine Finish Path
        // If Auto-Winner is ON or it's a Bomb Pot, we try to run the calculation automatically
        if ((game.autoWinner || game.isBombPot) && boardsReady) {
            performAutoShowdown();
        } 
        // If it's a Bomb Pot but boards aren't ready, we must ask for them
        else if (!boardsReady && game.isBombPot) {
            alert("Enter Board Cards to finish.");
            openBoardSelector();
        } 
        // Standard Manual Mode: Open the Manual Winner Selection Modal
        else {
            if (!game.isBombPot) {
                handleWinner(); // Opens the "Select Winner" modal
            }
        }
    }
}
        
        function performAutoShowdown() { 
    const active = game.players.filter(p => !p.folded && !p.sittingOut && !p.isOnBreak);
    if(active.length < 2) { alert("Not enough active players."); return; }
    
    // --- 1. CRITICAL UNDO FIX ---
    // We must "forget" that we finished this hand previously, 
    // otherwise finishHand will block execution.
    game.lastProcessedHandId = null; 

    pushUndoState(); 

    // --- 2. Bomb Pot / Runout Logic ---
    // If it's a Bomb Pot, we FORCE 2 runouts, otherwise use game settings
    const activeRunouts = game.isBombPot ? 2 : (game.runoutCount || 1);

    // --- 3. Safety Check: Board Cards ---
    for(let i=0; i < activeRunouts; i++) {
        // Initialize board if missing (prevents crash)
        if (!game.boards[i]) game.boards[i] = [];
        
        if(game.boards[i].length < 5) {
            if(confirm(`Board ${i+1} is incomplete. Enter board cards now?`)) startShowdownEntry(); 
            return;
        }
    }

    // --- 4. Calculate Pots ---
    const sidePots = calculatePotStructure();

    let totalWinnings = {};
    let breakdown = [];
    
    sidePots.forEach((potObj, potIdx) => {
        const isMain = (potIdx === sidePots.length - 1);
        const potName = isMain ? "Main Pot" : `Side Pot ${potIdx+1}`;

        // Split pot evenly across runouts
        let amountPerRun = potObj.amount / activeRunouts;
        
        for(let r=0; r < activeRunouts; r++) {
            const board = game.boards[r];
            
            // Evaluate hands
            let results = potObj.eligible.map(p => {
                let score;
                // PLO Logic (Requires 4 cards) vs HE Bomb Pot (Might have 2)
                const isPLO = (game.gameMode === 'plo'); // Strict PLO check
                
                if(isPLO) {
                   if(!p.cards || p.cards.length < 4) return { p:p, score: {rank:-1, name:"Invalid"}, idx: -1 }; 
                   score = getPLOHighHand(p.cards, board);
                } else {
                   // Texas Hold'em (Standard or Bomb Pot)
                   score = getHandStrength([...p.cards, ...board]); 
                }
                return { p: p, score: score };
            });
            
            // Filter invalid hands
            results = results.filter(r => r.score.rank !== -1);
            if(results.length === 0) continue; 

            // Find Winner(s)
            results.sort((a,b) => compareScores(b.score, a.score));
            const best = results[0].score;
            const winners = results.filter(r => compareScores(r.score, best) === 0);
            
            const winShare = amountPerRun / winners.length;
            
            winners.forEach(w => {
                if(!totalWinnings[w.p.name]) totalWinnings[w.p.name] = 0;
                totalWinnings[w.p.name] += winShare;
                
                breakdown.push({ 
                    name: w.p.name, 
                    amt: winShare, 
                    hand: `${w.score.name}${activeRunouts > 1 ? ` (Run ${r+1})` : ''}`, 
                    potName: potName 
                });
                
                // REMOVED: w.p.bombPotWins++ (This is now handled in finishHand)
            });
        }
    });
    
    // --- 5. Distribute Winnings ---
    let winnersFound = false;
    for(const [name, amt] of Object.entries(totalWinnings)) {
        const p = game.players.find(pl => pl.name === name);
        if(p) {
            p.stack += amt;
            p.showdownWins++; // We keep this here as finishHand doesn't auto-increment showdowns
            
            // Visual Flair
            const cardEl = document.querySelectorAll('.player-card')[game.players.indexOf(p)];
            if(cardEl) cardEl.classList.add('winner-anim');
            
            checkNitWinner(p);
            winnersFound = true;
        }
    }
    
    if(!winnersFound) {
        alert("Could not determine a winner. Check cards.");
        return;
    }
    
    // Close modal if open (e.g. if triggered from inside Manual Win)
    closeModal('modal-manual-win'); 
    
    // --- 6. FINISH ---
    finishHand(breakdown);
}
        
        const R_MAP = {'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'T':10,'J':11,'Q':12,'K':13,'A':14};
        
        function getHandStrength(cards) { 
            // FIX: Robust parsing to handle 'T' vs '10' and prevent crashes
            const vals = cards.map(c => {
                if(!c) return { r: 0, s: 'x' }; // Safety for bad data
                const suit = c.slice(-1);       
                const rankChar = c.slice(0, -1); 
                // Handle '10' specifically if it occurs, otherwise use map
                const rVal = (rankChar === '10') ? 10 : R_MAP[rankChar];
                return { r: rVal, s: suit };
            });
            
            vals.sort((a,b) => b.r - a.r);
            const suits = {}; vals.forEach(c => suits[c.s] = (suits[c.s]||0)+1);
            const flushSuit = Object.keys(suits).find(s => suits[s] >= 5);
            const flushCards = flushSuit ? vals.filter(c => c.s === flushSuit) : [];
            const uniqueRanks = [...new Set(vals.map(c => c.r))];
            
            let straightHigh = 0;
            for(let i=0; i<=uniqueRanks.length-5; i++) { if(uniqueRanks[i] - uniqueRanks[i+4] === 4) { straightHigh = uniqueRanks[i]; break; } }
            if(!straightHigh && uniqueRanks.includes(14) && uniqueRanks.includes(5) && uniqueRanks.includes(4) && uniqueRanks.includes(3) && uniqueRanks.includes(2)) straightHigh = 5;
            
            let strFlush = 0;
            if(flushSuit) {
                const fRanks = [...new Set(flushCards.map(c => c.r))];
                 for(let i=0; i<=fRanks.length-5; i++) { if(fRanks[i] - fRanks[i+4] === 4) { strFlush = fRanks[i]; break; } }
                if(!strFlush && fRanks.includes(14) && fRanks.includes(5) && fRanks.includes(4) && fRanks.includes(3) && fRanks.includes(2)) strFlush = 5;
            }
            if(strFlush) return { rank: 8, val: strFlush, name: "Straight Flush" };
            
            const counts = {}; vals.forEach(c => counts[c.r] = (counts[c.r]||0)+1);
            const four = parseInt(Object.keys(counts).find(r => counts[r]===4));
            const three = Object.keys(counts).filter(r => counts[r]===3).map(Number).sort((a,b)=>b-a);
            const pairs = Object.keys(counts).filter(r => counts[r]===2).map(Number).sort((a,b)=>b-a);
            
            if(four) return { rank: 7, val: four, kickers: vals.filter(c=>c.r!==four).map(c=>c.r).slice(0,1), name: "Four of a Kind" };
            if(three.length > 0 && pairs.length > 0) return { rank: 6, val: three[0], kickers: [pairs[0]], name: "Full House" };
            if(three.length > 1) return { rank: 6, val: three[0], kickers: [three[1]], name: "Full House" }; 
            if(flushSuit) return { rank: 5, kickers: flushCards.map(c=>c.r).slice(0,5), name: "Flush" };
            if(straightHigh) return { rank: 4, val: straightHigh, name: "Straight" };
            if(three.length > 0) return { rank: 3, val: three[0], kickers: vals.filter(c=>c.r!==three[0]).map(c=>c.r).slice(0,2), name: "Three of a Kind" };
            if(pairs.length > 1) return { rank: 2, val: pairs[0], kickers: [pairs[1], ...vals.filter(c=>c.r!==pairs[0] && c.r!==pairs[1]).map(c=>c.r).slice(0,1)], name: "Two Pair" };
            if(pairs.length > 0) return { rank: 1, val: pairs[0], kickers: vals.filter(c=>c.r!==pairs[0]).map(c=>c.r).slice(0,3), name: "Pair" };
            
            return { rank: 0, kickers: vals.map(c=>c.r).slice(0,5), name: "High Card" };
        }
        
        function compareScores(a, b) {
            if(a.rank !== b.rank) return a.rank - b.rank;
            if(a.val && b.val && a.val !== b.val) return a.val - b.val;
            for(let i=0; i<a.kickers.length; i++) {
                if(a.kickers[i] !== b.kickers[i]) return a.kickers[i] - b.kickers[i];
            }
            return 0;
        }

        function handleCall() {
    if (game.activePlayerIndex === -1) return;

    // Safety check: Ensure board cards are set before betting proceeds on streets > 0
    if (!validateBoardState()) {
        alert(`Please input all necessary Board Cards first!`);
        openBoardSelector();
        return;
    }

    pushUndoState();
    stopTurnTimer();

    // Calculate the call amount (diff)
    let max = 0;
    game.players.forEach(p => max = Math.max(max, p.currentBet));
    const p = game.players[game.activePlayerIndex];
    const diff = max - p.currentBet;

    // Track stats
    if (game.street > 0 && !p.folded) {
        p.postFlopOpportunities++;
    }

    // --- LOGIC SPLIT: LAZY VS STRICT ---

    // SCENARIO 1: LAZY MODE (Infinite Stacks)
    // Players just match the bet. Stacks can go negative.
    if (game.lazyMode) {
        placeBetLogic(game.activePlayerIndex, diff);

        if (diff === 0) {
            p.isChecked = true;
            p.hasActed = true;
            p.lastAction = "CHECK";
            saveReplayStep(`${p.name}: Check`);
        } else {
            // Note: In lazy mode, we don't force All-In text usually
            p.lastAction = "CALL " + formatMoney(diff);
            saveReplayStep(`${p.name}: Call ${formatMoney(diff)}`);
        }

        advanceTurn();
        return;
    }

    // SCENARIO 2: STRICT MODE (Real Chips)
    // If diff > stack, player goes All-In for what they have.
    if (diff >= p.stack) {
        const actual = p.stack; // Bet whatever is left
        placeBetLogic(game.activePlayerIndex, actual);
        
        // Override label to be clear it was a Call-based All-In
        p.lastAction = "ALL IN (Call)";
        saveReplayStep(`${p.name}: ALL IN (Call) ${formatMoney(actual)}`);
    } 
    // Otherwise, standard Call/Check
    else {
        if (diff === 0) {
            p.isChecked = true;
            p.hasActed = true;
            p.lastAction = "CHECK";
            saveReplayStep(`${p.name}: Check`);
        } else {
            placeBetLogic(game.activePlayerIndex, diff);
            p.lastAction = "CALL " + formatMoney(diff);
            saveReplayStep(`${p.name}: Call ${formatMoney(diff)}`);
        }
    }

    advanceTurn();
}

        function handleFold() {
    if (game.activePlayerIndex === -1) return;
    
    pushUndoState();
    stopTurnTimer();
    
    const p = game.players[game.activePlayerIndex];
    
    // Track stats
    if (game.street > 0) {
        p.postFlopOpportunities++;
    }
    
    p.folded = true;
    p.hasActed = true;
    
    // --- NEW: Track exactly when they folded for WTSD% stats ---
    p.foldedStreet = game.street; 
    // -----------------------------------------------------------

    p.lastAction = "FOLD";
    saveReplayStep(`${p.name}: Fold`);
    
    advanceTurn();
}

        function confirmBet() {
    const val = parseFloat(game.tempBet); 
    if(isNaN(val)) return closeModal('modal-bet');
    
    const p = game.players[game.activePlayerIndex];
    
    // Calculate what the Total bet would be
    let tot = game.isAddMode ? p.currentBet + val : val;
    
    // Calculate strict limits
    const maxFunds = p.stack + p.currentBet;
    let actionText = "";

    // --- CHANGED LOGIC HERE ---
    if (game.lazyMode) {
        // CASUAL MODE: "Infinite Stacks"
        if(tot <= p.currentBet && tot !== 0) { 
            alert(`Invalid Bet: Must be > ${p.currentBet}`); 
            return; 
        }
        actionText = "RAISE " + formatMoney(tot);

    } else {
        // BOOKKEEPING MODE: Strict Limits
        if(tot >= maxFunds) { 
            tot = maxFunds; 
            actionText = "ALL IN " + formatMoney(tot); 
        } 
        else if(tot <= p.currentBet) { 
            alert(`Invalid Bet: Must be > ${p.currentBet}`); 
            return; 
        } 
        else { 
            actionText = "RAISE " + formatMoney(tot); 
        }
    }
    // --------------------------

    const diff = tot - p.currentBet;
    
    if(diff > 0) {
        pushUndoState(); 
        stopTurnTimer(); 
        
        // This calculates chips AND sets the new "p.hasPFR / p.has3Bet" flags
        placeBetLogic(game.activePlayerIndex, diff);
        
        // --- FIXED SECTION: REMOVED STATS MATH ---
        if(game.street === 0) {
            // We KEEP this because the game needs to know how many raises happened
            game.preflopRaiseCount++;
            
            // DELETED: p.pfrHands++ (Handled by finishHand now)
            // DELETED: p.threeBetHands++ (Handled by finishHand now)
        } else {
            // Post-flop stats can remain here for now if they aren't causing issues
            p.postFlopAggressiveActions++; 
            p.postFlopOpportunities++;
        }
        // -----------------------------------------
        
        // Force the label we decided on above (Overriding automatic logic)
        p.lastAction = actionText; 
        saveReplayStep(`${p.name}: ${actionText}`);
        
        advanceTurn();
    }
    closeModal('modal-bet');
}

        function handleStraddle() {
    if(game.street !== 0) return alert("Straddle only Preflop");
    
    pushUndoState();

    let amt = (game.currentStraddleAmt === 0) ? game.bb * 2 : game.currentStraddleAmt * 2;
    // Standard straddle is usually UTG (Dealer + 3). If re-straddle, it's next player.
    let target = (game.currentStraddleAmt === 0) ? getNextActive(game.dealerIndex + 3) : getNextActive(game.lastStraddleIdx + 1);
    
    const p = game.players[target];
    
    // Determine Amount and String
    let actualAmt = amt;
    let actionStr = "STRAD " + formatMoney(amt);
    
    if(amt >= p.stack) { 
        actualAmt = p.stack; 
        actionStr = "ALL IN (STRAD)"; 
    } 
    
    saveReplayStep(`Action: ${p.name} Straddles ${actualAmt}`);
    
    // 1. Update Chips/Stacks
    placeBetLogic(target, actualAmt); 
    
    // 2. CRITICAL FIX: Overwrite the action text back to "STRAD" 
    // (placeBetLogic would have changed it to "RAISE" or "BET")
    p.lastAction = actionStr;

    game.currentStraddleAmt = actualAmt; 
    game.lastStraddleIdx = target;
    
    // Move to next player
    game.activePlayerIndex = getNextActive(target + 1); 
    renderTable();
}

        function handleWinner() {
            if(game.activePlayerIndex === -1 && !game.isShowdownEntry && game.street !== 4) return alert("Select Winner");
            
            // 1. Calculate the Pots
            const pots = calculatePotStructure();
            
            // 2. Render the Manual Win Screen
            const container = document.getElementById('manual-pot-container');
            container.innerHTML = "";
            
            // Save pots to game state so we can access them in 'confirmManualWin'
            game.manualPots = pots; 
            game.manualSelections = {}; // Stores { potIndex: [playerIndices] }

            pots.forEach((pot, potIdx) => {
                const isMain = (potIdx === pots.length - 1); // Assuming sorted by eligible count
                const label = isMain ? "MAIN POT" : `SIDE POT #${potIdx+1}`;
                
                const potDiv = document.createElement('div');
                potDiv.style.background = "#222";
                potDiv.style.border = "1px solid #444";
                potDiv.style.borderRadius = "8px";
                potDiv.style.padding = "10px";
                
                let eligibleHtml = "";
                pot.eligible.forEach(p => {
                    const pIdx = game.players.indexOf(p);
                    eligibleHtml += `
                        <div class="manual-winner-item" id="p-sel-${potIdx}-${pIdx}" onclick="toggleManualPotWinner(${potIdx}, ${pIdx})" style="padding:8px; font-size:14px;">
                            <span>${p.name}</span>
                            <span class="manual-check" id="check-${potIdx}-${pIdx}" style="display:none;">‚úì</span>
                        </div>
                    `;
                });

                potDiv.innerHTML = `
                    <div style="display:flex; justify-content:space-between; margin-bottom:5px; border-bottom:1px solid #333; padding-bottom:5px;">
                        <span style="font-weight:bold; color:${isMain ? 'var(--accent-green)' : 'var(--accent-gold)'}">${label}</span>
                        <span style="font-weight:bold;">${formatMoney(pot.amount)}</span>
                    </div>
                    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
                        ${eligibleHtml}
                    </div>
                `;
                container.appendChild(potDiv);
            });

            document.getElementById('modal-manual-win').classList.add('open');
        }

        // Helper for the selection click
        function toggleManualPotWinner(potIdx, pIdx) {
            if(!game.manualSelections[potIdx]) game.manualSelections[potIdx] = [];
            
            const list = game.manualSelections[potIdx];
            const idxInList = list.indexOf(pIdx);
            
            const el = document.getElementById(`p-sel-${potIdx}-${pIdx}`);
            const check = document.getElementById(`check-${potIdx}-${pIdx}`);
            
            if(idxInList > -1) {
                list.splice(idxInList, 1);
                el.classList.remove('selected');
                check.style.display = "none";
            } else {
                list.push(pIdx);
                el.classList.add('selected');
                check.style.display = "inline";
            }
        }

        function toggleManualWinner(el, idx) {
            if (game.selectedManualWinners.includes(idx)) {
                game.selectedManualWinners = game.selectedManualWinners.filter(i => i !== idx);
                el.classList.remove('selected');
            } else {
                game.selectedManualWinners.push(idx);
                el.classList.add('selected');
            }
        }

        function confirmManualWin() {
    pushUndoState();
    
    let breakdown = [];
    let potsProcessed = 0;
    
    // 1. Identify all unique winners (for internal logic)
    const allUniqueWinners = new Set();

    game.manualPots.forEach((pot, potIdx) => {
        const winnersIndices = game.manualSelections[potIdx] || [];
        
        if(winnersIndices.length > 0) {
            const splitAmt = pot.amount / winnersIndices.length; 
            const isMain = (potIdx === game.manualPots.length - 1);
            const potName = isMain ? "Main Pot" : `Side Pot ${potIdx+1}`;
            
            winnersIndices.forEach(pIdx => {
                const w = game.players[pIdx];
                w.stack += splitAmt;
                w.showdownWins++; 
                
                checkNitWinner(w);
                allUniqueWinners.add(w);
                
                breakdown.push({ 
                    name: w.name, 
                    amt: splitAmt, 
                    hand: winnersIndices.length > 1 ? `Manual Split (${winnersIndices.length} ways)` : "Manual Winner",
                    potName: potName
                });
            });
            potsProcessed++;
        }
    });
    
    if(potsProcessed === 0) return alert("Please select at least one winner for a pot.");
    
    // --- 2. 7-2 BOUNTY LOGIC ---
    // Check if the 7-2 box (from the new HTML I gave you) is checked
    const is72Claimed = document.getElementById('manual-72-claim') ? document.getElementById('manual-72-claim').checked : false;
    
    if (is72Claimed && allUniqueWinners.size > 0) {
        // Logic: The first winner gets the bounty.
        const bountyHunter = [...allUniqueWinners][0];
        const penalty = (game.nitSettings && game.nitSettings.amount) ? game.nitSettings.amount : (game.bb * 2);

        let bountyTotal = 0;
        game.players.forEach(p => {
            // Everyone who ISN'T the winner and HAS chips pays
            if (p.name !== bountyHunter.name && !p.sittingOut && p.stack > 0) {
                const pay = Math.min(p.stack, penalty);
                p.stack -= pay;
                bountyTotal += pay;
            }
        });
        
        bountyHunter.stack += bountyTotal;
        bountyHunter.sevenDeuceWins = (bountyHunter.sevenDeuceWins || 0) + 1;
        
        // Add note to breakdown
        breakdown.push({
            name: bountyHunter.name,
            amt: bountyTotal,
            hand: "7-2 Bounty Collected",
            potName: "Side Game"
        });
    }

    // Reset Checkbox if it exists
    if(document.getElementById('manual-72-claim')) document.getElementById('manual-72-claim').checked = false;
    
    closeModal('modal-manual-win');
    
    // --- 3. FINISH HAND (Stats & History) ---
    finishHand(breakdown);
}
        
        function finishHand(breakdown) {
    // --- 1. SAFETY LATCH ---
    // (We keep this for immediate double-click protection)
    if (game.lastProcessedHandId === game.handCount) {
        return;
    }
    game.lastProcessedHandId = game.handCount;

    const finalPot = game.pot;
    const currentId = game.handCount;
    
    // CAPTURE PLAYER STATE (Cards)
    // We snapshot this NOW before we clear the board
    const playerSnapshot = JSON.parse(JSON.stringify(game.players));

    // --- 2. UPDATE STATS ---
    updateAdvancedStats(breakdown);

    if (game.isBombPot) {
        const uniqueWinnerNames = [...new Set(breakdown.map(item => item.name))];
        uniqueWinnerNames.forEach(name => {
            const p = game.players.find(pl => pl.name === name);
            if (p) p.bombPotWins = (p.bombPotWins || 0) + 1;
        });
    }

    game.players.forEach(p => {
        if (!p.sittingOut && !p.isOnBreak) {
            if (p.hasVPIP) p.vpipHands = (p.vpipHands || 0) + 1;
            if (p.hasPFR) p.pfrHands = (p.pfrHands || 0) + 1;
            if (p.has3Bet) p.threeBetHands = (p.threeBetHands || 0) + 1;
        }
    });

    // --- 3. PREPARE HISTORY RECORD ---
    const fullHandRecord = {
        id: currentId,
        time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
        dealerIdx: game.dealerIndex,
        winners: breakdown,
        pot: formatMoney(finalPot),
        potValue: finalPot,
        board: JSON.parse(JSON.stringify(game.boards)),
        replayData: JSON.parse(JSON.stringify(game.currentHandReplay)),
        playerState: playerSnapshot, // Saves cards
        favorite: game.currentHandFavorite || false,
        isBombPot: game.isBombPot || false
    };

    const summaryRecord = { ...fullHandRecord };
    delete summaryRecord.replayData; 
    // We KEEP playerState in summary so cards show up in the list!

    // --- 4. PREVENT DUPLICATES (The Fix) ---
    // If we are re-saving Hand #1 because of an undo, remove the old Hand #1 first
    game.history = game.history.filter(h => h.id !== currentId);
    
    // Now add the new clean record
    game.history.unshift(summaryRecord);
    saveHandToPermanentStorage(fullHandRecord);

    // --- 5. CLEANUP & INCREMENT ---
    game.handCount = currentId + 1;
    saveLocal();

    game.pot = 0;
    game.players.forEach(p => {
        p.currentBet = 0;
        p.handTotalBet = 0;
        p.foldedStreet = null;      
        p.hasVPIP = false;
        p.hasPFR = false;
        p.has3Bet = false;
        p.cards = []; // Clear cards
    });

    // --- 6. DISPLAY RESULT ---
    if (breakdown.length > 0) {
        openWinnerModal(breakdown, finalPot);
    } else {
        checkBustedPlayers();
    }
}
        
        function renderStats(sortBy, tab) {
    // 1. Handle Sorting Direction
    const currentDir = sortColumn[tab] === sortBy ? sortDirection[tab] * -1 : 1;
    sortDirection[tab] = currentDir; 
    sortColumn[tab] = sortBy;

    // 2. Select Table Elements
    const tableId = tab === 'basic' ? '#stats-table' : '#advanced-stats-table';
    const tbody = document.querySelector(`${tableId} tbody`);
    
    // 3. Highlight Active Sort Header
    document.querySelectorAll(`${tableId} th`).forEach(th => th.classList.remove('active-sort'));
    const headerCell = document.querySelector(`${tableId} th[onclick*="'${sortBy}'"]`);
    if (headerCell) headerCell.classList.add('active-sort');

    // 4. Sort the Players
    let sorted = [...game.players];
    sorted.sort((a, b) => { 
        let valA, valB; 
        const getPct = (num, den) => den > 0 ? (num/den) : 0;
        const getStat = (p, key) => (p.stats && p.stats[key]) ? parseFloat(p.stats[key]) : 0;

        if (sortBy === 'profit') { 
            valA = a.stack - (a.buyInTotal + (a.rebuyTotal || 0)); 
            valB = b.stack - (b.buyInTotal + (b.rebuyTotal || 0)); 
        }
        else if (sortBy === 'buyin') { valA = a.buyInTotal; valB = b.buyInTotal; }
        else if (sortBy === 'rebuy') { valA = a.rebuyTotal; valB = b.rebuyTotal; }
        else if (sortBy === 'nit') { valA = a.nitCount; valB = b.nitCount; }
        else if (sortBy === 'time') { 
            valA = a.totalDecisions > 0 ? a.totalTime / a.totalDecisions : 0; 
            valB = b.totalDecisions > 0 ? b.totalTime / b.totalDecisions : 0; 
        }
        else if (sortBy === '72') { valA = a.sevenDeuceWins; valB = b.sevenDeuceWins; }
        else if (sortBy === 'bomb') { valA = a.bombPotWins; valB = b.bombPotWins; }
        else if (sortBy === 'vpip') { valA = getPct(a.vpipHands, a.totalHands); valB = getPct(b.vpipHands, b.totalHands); }
        else if (sortBy === 'pfr') { valA = getPct(a.pfrHands, a.totalHands); valB = getPct(b.pfrHands, b.totalHands); }
        else if (sortBy === '3bet') { valA = getPct(a.threeBetHands, a.totalHands); valB = getPct(b.threeBetHands, b.totalHands); }
        else if (sortBy === 'afq') { 
            valA = getPct(a.postFlopAggressiveActions, a.postFlopOpportunities); 
            valB = getPct(b.postFlopAggressiveActions, b.postFlopOpportunities); 
        }
        else if (sortBy === 'wsd') { valA = getStat(a, 'wsdPercent'); valB = getStat(b, 'wsdPercent'); }
        else if (sortBy === 'wtsd') { valA = getStat(a, 'wtsdPercent'); valB = getStat(b, 'wtsdPercent'); }
        else return a.name.localeCompare(b.name); 
        return currentDir * (valB - valA);
    });
    
    // 5. Render HTML
    tbody.innerHTML = ""; 
    sorted.forEach(p => { 
        if (tab === 'basic') {
            const initial = p.buyInTotal || 0;
            const rebuys = p.rebuyTotal || 0;
            const profit = p.stack - (initial + rebuys);
            const avgTime = p.totalDecisions > 0 ? (p.totalTime / p.totalDecisions / 1000).toFixed(1) + 's' : '-';
            const profitClass = profit > 0 ? 'stat-green' : (profit < 0 ? 'stat-red' : 'stat-gray');

            tbody.innerHTML += `<tr>
                <td style="font-weight:bold;">${p.name}</td>
                <td class="stat-cell ${profitClass}">${profit >= 0 ? '+' : ''}${formatMoney(profit)}</td>
                <td class="stat-cell">${formatMoney(initial)}</td>
                <td class="stat-cell">${formatMoney(rebuys)} <span style="font-size:10px; color:#888;">(${p.rebuyCount || 0}R)</span></td>
                <td class="stat-cell">${p.nitCount}</td>
                <td class="stat-cell" style="font-size:11px;">${avgTime}</td>
                <td class="stat-cell">${p.sevenDeuceWins}</td>
                <td class="stat-cell">${p.bombPotWins}</td>
            </tr>`;
        } else {
            const hands = p.totalHands || 0;
            const vpip = hands > 0 ? Math.round((p.vpipHands / hands) * 100) : 0;
            const pfr = hands > 0 ? Math.round((p.pfrHands / hands) * 100) : 0;
            const threeBet = hands > 0 ? Math.round((p.threeBetHands / hands) * 100) : 0;
            const afq = p.postFlopOpportunities > 0 ? Math.round((p.postFlopAggressiveActions / p.postFlopOpportunities) * 100) : 0;
            const stats = p.stats || { wsdPercent: 0, wtsdPercent: 0 };
            const wsd = parseFloat(stats.wsdPercent);
            const wtsd = parseFloat(stats.wtsdPercent);

            const vpipClass = vpip > 40 ? 'stat-green' : (vpip < 20 ? 'stat-red' : '');
            const pfrClass = pfr > 30 ? 'stat-green' : (pfr < 10 ? 'stat-red' : '');
            const bet3Class = threeBet > 10 ? 'stat-green' : (threeBet < 3 ? 'stat-red' : '');
            const afqClass = afq > 50 ? 'stat-green' : (afq < 30 ? 'stat-red' : '');
            const wsdClass = wsd > 55 ? 'stat-green' : (wsd < 45 ? 'stat-red' : '');
            const wtsdClass = wtsd > 30 ? 'stat-green' : (wtsd < 20 ? 'stat-red' : '');

            tbody.innerHTML += `<tr>
                <td style="font-weight:bold; text-align:left;">${p.name} <span style="font-size:9px; color:#555">(${hands}h)</span></td>
                <td class="stat-cell ${vpipClass}">${vpip}%</td>
                <td class="stat-cell ${pfrClass}">${pfr}%</td>
                <td class="stat-cell ${bet3Class}">${threeBet}%</td>
                <td class="stat-cell ${afqClass}">${afq}%</td>
                <td class="stat-cell ${wsdClass}">${wsd}%</td>
                <td class="stat-cell ${wtsdClass}">${wtsd}%</td>
            </tr>`;
        }
    });
}
        
        function openWinnerModal(breakdown, finalPotValue) {
            // Use the passed value, or fallback to game.pot if missing
            const totalPot = (finalPotValue !== undefined) ? finalPotValue : game.pot;
            
            // Generate Detailed HTML List
            let detailsHtml = `<div style="display:flex; flex-direction:column; gap:8px; width:100%; margin-top:15px;">`;
            
            breakdown.forEach(item => {
                const potLabel = item.potName || "Pot";
                const handLabel = item.hand || "Winner";
                
                detailsHtml += `
                    <div style="background:#333; padding:10px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; border-left:4px solid var(--accent-green);">
                        <div style="text-align:left;">
                            <div style="font-weight:bold; color:white;">${item.name}</div>
                            <div style="font-size:11px; color:#aaa;">${potLabel} ‚Ä¢ ${handLabel}</div>
                        </div>
                        <div style="font-weight:bold; color:var(--accent-gold); font-size:18px;">+${formatMoney(item.amt)}</div>
                    </div>
                `;
            });
            detailsHtml += `</div>`;

            // Update DOM
            const contentDiv = document.querySelector('.winner-content');
            contentDiv.innerHTML = `
                <h2 style="color:white; font-size:24px; margin:0;">WINNER</h2>
                <div style="font-size:40px; color:var(--accent-green); font-weight:900; margin:5px 0;">+${formatMoney(totalPot)}</div>
                ${detailsHtml}
                <button id="btn-undo-result" class="btn-undo-win" style="margin-top:20px;"><span>‚Ü∫</span> Undo Result</button>
            `;
            
            // Re-attach Undo Event
            document.getElementById('btn-undo-result').onclick = (e) => { e.stopPropagation(); undoLastAction(); };

            document.getElementById('modal-winner').classList.add('open');
            
            if (game.winnerTimeout) clearTimeout(game.winnerTimeout);
            game.winnerTimeout = null;
            
            // Note: game.pot is already 0 from finishHand, which is correct
        }
        
        function closeWinnerModal() {
            if (game.winnerTimeout) { clearTimeout(game.winnerTimeout); game.winnerTimeout = null; }
            document.getElementById('modal-winner').classList.remove('open');
			checkBustedPlayers();
        }

        // --- BUST / REBUY LOGIC ---
        function checkBustedPlayers() {
            let busted = [];
            
            game.players.forEach((p, i) => {
                if(!p.sittingOut) { 
                    // FIX: In Casual Mode, Negative Stack (-50) is NOT busted. 
                    // Only exactly 0 is considered "No Chips".
                    // In Strict Mode, < 0.01 is busted.
                    
                    let isBusted = false;
                    if (game.lazyMode) {
                        // Casual: Bust only if stack is effectively 0 (meaning they matched bets exactly to 0)
                        // If they went negative, they are "Playing on Credit", so NOT busted.
                        isBusted = (Math.abs(p.stack) < 0.01);
                    } else {
                        // Strict: Bust if 0 or Negative
                        isBusted = (p.stack < 0.01);
                    }

                    if (isBusted) {
                        busted.push({ name: p.name, idx: i });
                    }
                }
            });

            if(busted.length > 0) {
                const list = document.getElementById('bust-list');
                list.innerHTML = "";
                
                busted.forEach(item => {
                    const p = game.players[item.idx];
                    const div = document.createElement('div'); 
                    div.className = "bust-row";
                    div.innerHTML = `
                        <span class="bust-name">${p.name} is Busted!</span>
                        <div class="bust-actions">
                            <input type="number" id="bust-input-${item.idx}" class="bust-input" value="${game.minBuyin}" min="${game.minBuyin}" max="${game.maxBuyin}">
                            <button class="btn" style="background:var(--accent-green); color:black; font-weight:bold; flex:1;" onclick="confirmBustRebuy(${item.idx})">Rebuy</button>
                            <button class="btn" style="background:#555; flex:1;" onclick="toggleSitOut(${item.idx})">Sit Out</button>
                        </div>
                    `;
                    list.appendChild(div);
                });
                
                document.getElementById('modal-bust').classList.add('open');
            } else {
                document.getElementById('modal-bust').classList.remove('open');
                if (game.handCount % 5 === 0) saveLocal(); 
                newHand(); 
            }
        }

        function confirmBustRebuy(idx) {
    const input = document.getElementById(`bust-input-${idx}`);
    if(!input) return;
    const amt = parseFloat(input.value);
    
    if(isNaN(amt) || amt < game.minBuyin || amt > game.maxBuyin) {
        alert(`Please enter an amount between ${game.minBuyin} and ${game.maxBuyin}`); 
        return;
    }

    const p = game.players[idx]; 
    
    // --- LOGIC: ADD TO REBUY BUCKET ONLY ---
    p.stack += amt;                           
    p.rebuyTotal = (p.rebuyTotal || 0) + amt; 
    p.rebuyCount = (p.rebuyCount || 0) + 1;   
    
    // Initial Buy-in (p.buyInTotal) is left untouched to preserve the starting amount.

    p.sittingOut = false; 
    p.folded = false;
    
    const stillBusted = game.players.some(p => p.stack <= 0 && !p.sittingOut);
    if (!stillBusted) {
         document.getElementById('modal-bust').classList.remove('open');
         newHand();
    } else {
         checkBustedPlayers();
    }
}

        function quickRebuy(idx, amt) {
    const p = game.players[idx]; 
    
    p.stack += amt; 
    p.rebuyTotal = (p.rebuyTotal || 0) + amt; 
    p.rebuyCount = (p.rebuyCount || 0) + 1; 
    
    p.sittingOut = false; 
    p.folded = false;
    checkBustedPlayers();
}
        function toggleSitOut(idx) {
            game.players[idx].sittingOut = true; game.players[idx].folded = true; checkBustedPlayers();
        }
        function processBustsAndContinue() {
            const stillBusted = game.players.some(p => p.stack <= 0 && !p.sittingOut);
            if(stillBusted) { alert("Some players still have 0 chips. Please Rebuy or Sit Out."); checkBustedPlayers(); return; }
            document.getElementById('modal-bust').classList.remove('open'); newHand();
        }
        function closeNitAlert() { document.getElementById('nit-overlay').classList.remove('visible'); renderTable(); }

        // --- MENU ACTIONS ---
        function toggleFavorite(i) {
            if (game.history[i]) { game.history[i].favorite = !game.history[i].favorite; openMenuModal(); saveLocal(); }
        }
        function openMenuModal() { 
			const btnCasual = document.getElementById('btn-casual-mode');
			if(btnCasual) {
				// Check the actual game state
				btnCasual.innerText = game.lazyMode ? "CASUAL: ON" : "CASUAL: OFF";
				btnCasual.style.background = game.lazyMode ? "var(--accent-gold)" : "#555";
				btnCasual.style.color = game.lazyMode ? "black" : "white";
				}
            // Default threshold
            if(!game.bigPotThreshold) game.bigPotThreshold = 50;

            const hList = document.getElementById('history-list'); 
            
            // --- 1. NEW: BIG POT SETTINGS (Inject if missing) ---
            if(!document.getElementById('big-pot-settings')) {
                const settings = document.createElement('div');
                settings.id = 'big-pot-settings';
                settings.style.marginBottom = '10px';
                settings.style.padding = '8px';
                settings.style.background = '#222';
                settings.style.border = '1px solid #444';
                settings.style.borderRadius = '5px';
                settings.innerHTML = `
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <label style="color:#aaa; font-size:12px;">"Big Pot" Threshold ($)</label>
                        <div style="display:flex; gap:5px;">
                            <input type="number" id="big-pot-input" value="${game.bigPotThreshold}" 
                                   style="width:70px; padding:5px; border-radius:4px; border:1px solid #444; background:#111; color:white;">
                            <button class="btn" onclick="saveBigPotThreshold()" style="width:auto; padding:5px 10px; font-size:12px;">Save</button>
                        </div>
                    </div>
                `;
                // Insert at the very top of history section (before the list)
                hList.parentNode.insertBefore(settings, hList);
            }

            // --- 2. DYNAMIC FILTER CONTROLS (Your Code + Bomb Option) ---
            if(!document.getElementById('history-filter-controls')) {
                const controls = document.createElement('div');
                controls.id = 'history-filter-controls';
                controls.style.marginBottom = '10px';
                controls.style.display = 'flex';
                controls.style.flexDirection = 'column'; 
                controls.style.gap = '8px';
                
                // Generate Player Options
                let playerOptions = `<option value="all">All Players</option>`;
                game.players.forEach(p => {
                    playerOptions += `<option value="${p.name}">${p.name}</option>`;
                });

                controls.innerHTML = `
                    <div style="display:flex; gap:5px;">
                        <select onchange="setHistoryFilter(this.value)" style="padding:8px; background:#333; color:white; border:1px solid #555; border-radius:5px; flex:1;">
                            <option value="all">All Types</option>
                            <option value="fav">‚òÖ Favorites</option>
                            <option value="bigpot">üí∞ Big Pots</option>
                            <option value="bomb">üí£ Bomb Pots</option> <option value="allin">üî¥ All In</option>
                            <option value="showdown">üÉè Showdowns</option>
                            <option value="bust">üíÄ Busts</option>
                        </select>
                        
                        <select id="history-player-select" onchange="setHistoryPlayerFilter(this.value)" style="padding:8px; background:#333; color:white; border:1px solid #555; border-radius:5px; flex:1;">
                            ${playerOptions}
                        </select>
                    </div>
                `;
                // Insert before the history list (but after settings if created)
                hList.parentNode.insertBefore(controls, hList);
            } else {
                 // Refresh Player Options if modal is re-opened
                 const pSelect = document.getElementById('history-player-select');
                 if(pSelect) {
                      let playerOptions = `<option value="all">All Players</option>`;
                      game.players.forEach(p => {
                          const sel = (game.historyPlayerFilter === p.name) ? "selected" : "";
                          playerOptions += `<option value="${p.name}" ${sel}>${p.name}</option>`;
                      });
                      pSelect.innerHTML = playerOptions;
                 }
            }

            // --- 3. CALL THE SEPARATE FUNCTION ---
            renderHistoryList();

            // --- 4. MANAGE TAB (Your Original Code) ---
            const mList = document.getElementById('manage-list'); 
            if(mList) {
                mList.innerHTML = ""; 
                game.players.forEach((p,i) => {
                    let toggleBtnClass = p.isOnBreak ? 'active' : '';
                    let toggleIcon = '‚òï';
                    let toggleTitle = 'Toggle Break';
                    if (p.sittingOut) { toggleBtnClass = 'sitting-out'; toggleIcon = 'üö´'; toggleTitle = 'Sitting Out'; }
                    
                    mList.innerHTML += `
                    <div class="manage-row" style="${swapSourceIndex === i ? 'border: 2px solid var(--accent-gold);' : ''}">
						<input type="text" class="manage-input" value="${p.name}" onchange="renamePlayer(${i}, this.value)">
						<div class="manage-controls">
							<button class="btn" style="background:${swapSourceIndex === i ? 'var(--accent-gold)' : '#555'}; color:white; padding:0 12px; font-size:16px;" onclick="toggleSwapSelect(${i})">‚áÑ</button>
        
							<button class="btn-break-toggle ${toggleBtnClass}" onclick="togglePlayerBreak(${i})" title="${toggleTitle}">${toggleIcon}</button>
							<button class="btn-rebuy" onclick="openRebuyModal(${i})">Rebuy</button>
							<button class="btn-kick" onclick="kick(${i})">X</button>
						</div>
						<div style="font-size:10px; color:#aaa; text-align:right; margin-top:4px;">
							Stack: ${formatMoney(p.stack)} 
							<button class="btn-edit-stack" onclick="openStackAdjustment(${i})">‚úé</button>
						</div>
					</div>`;
                });
            }

            // --- 5. EXPORT BUTTONS (Your Original Code) ---
            if(!document.getElementById('export-controls-container') && mList) {
                 const container = document.createElement('div');
                 container.id = 'export-controls-container';
                 container.innerHTML = `
                    <div style="display:flex; gap:10px; margin-top:15px;">
                        <button class="btn" style="background:var(--accent-green); flex:1;" onclick="exportSessionToExcel()">üìä Export Session Excel</button>
						<button class="btn" style="background:var(--accent-blue); flex:1;" onclick="saveSessionFile()">üíæ Save Game</button>
                    </div>
                    <button class="btn" style="background:#444; border:1px dashed #777; width:100%; margin-top:10px;" onclick="triggerLoadSession()">üìÇ Load Saved Game</button>
                    <input type="file" id="file-input-session" style="display:none" accept=".json" onchange="loadSessionFile(this)">
                 `;
                 // Append to the parent of the Manage List
                 mList.parentNode.appendChild(container);
            }

            renderStats('profit', 'basic'); 
            switchTab('tab-manage'); 
            const btn = document.getElementById('btn-auto-win');
            if(btn) { 
                btn.innerText = game.autoWinner ? "AUTO WIN: ON" : "AUTO WIN: OFF"; 
                btn.style.background = game.autoWinner ? "var(--accent-green)" : "#555"; 
            }
            document.getElementById('modal-menu').classList.add('open');
        }

        // --- STACK CORRECTION LOGIC ---
        function openStackAdjustment(i) {
    game.contextPlayerIdx = i;
    const p = game.players[i];

    // Load existing values
    document.getElementById('adjust-stack-input').value = p.stack;
    document.getElementById('adjust-buyin-input').value = p.buyInTotal;

    // --- NEW: Load Rebuy Values ---
    // We use || 0 to ensure it shows 0 if the value is undefined
    document.getElementById('adjust-rebuy-amt-input').value = p.rebuyTotal || 0;
    document.getElementById('adjust-rebuy-count-input').value = p.rebuyCount || 0;

    document.getElementById('modal-menu').classList.remove('open');
    document.getElementById('modal-adjust-stack').classList.add('open');
}

function saveStackAdjustment() {
    const i = game.contextPlayerIdx;
    const p = game.players[i];

    // 1. Capture old values
    const oldStack = p.stack;
    const oldBuyIn = parseFloat(p.buyInTotal) || 0;
    const oldRebuyAmt = parseFloat(p.rebuyTotal) || 0; // NEW: Track old rebuys
    const oldCorrection = p.casualCorrection || 0;

    // 2. Get new inputs from the user
    const newStack = parseFloat(document.getElementById('adjust-stack-input').value);
    const newBuyInVal = parseFloat(document.getElementById('adjust-buyin-input').value);
    const newRebuyAmt = parseFloat(document.getElementById('adjust-rebuy-amt-input').value);
    const newRebuyCount = parseInt(document.getElementById('adjust-rebuy-count-input').value);

    // Validation
    if (isNaN(newStack) || isNaN(newBuyInVal) || isNaN(newRebuyAmt) || isNaN(newRebuyCount)) {
        alert("Invalid numbers entered.");
        return;
    }

    // 3. Update The Player Data (Strict Separation)
    p.stack = newStack;
    p.buyInTotal = newBuyInVal;   // Strictly Initial Buy-in
    p.rebuyTotal = newRebuyAmt;   // Strictly Rebuy Amount
    p.rebuyCount = newRebuyCount; 

    // 4. CRITICAL: Re-balance the "Ghost Ledger" (Casual Correction)
    // We calculate "Total Equity" (Cash In + Corrections) to ensure manual stack changes don't break the pot logic.
    
    // OLD FORMULA (Missing Rebuys): const oldTotalEquity = oldBuyIn + oldCorrection;
    // NEW FORMULA (Correct):
    const oldTotalEquity = oldBuyIn + oldRebuyAmt + oldCorrection;
    
    const stackDiff = newStack - oldStack;
    const targetEquity = oldTotalEquity + stackDiff;
    
    // Math: NewCorrection = TargetEquity - (All Cash Put In)
    p.casualCorrection = targetEquity - (newBuyInVal + newRebuyAmt);

    // 5. Recalculate Global Pot & UI
    game.pot = recalculateGlobalPot();

    closeModal('modal-adjust-stack');
    openMenuModal();
    renderTable();
    
    // Refresh stats if they are visible
    if(document.getElementById('modal-menu').classList.contains('active')) {
         if(typeof renderStats === 'function') renderStats('name', 'basic');
    }

    saveReplayStep(`Correction: Manual Adjustment for ${p.name} (Stack:${newStack}, BuyIn:${newBuyInVal}, Rebuys:${newRebuyAmt})`);
}

        // --- REBUY LOGIC & RESTART HAND ---
        function openRebuyModal(i) {
            game.contextPlayerIdx = i; const p = game.players[i];
            document.getElementById('rebuy-player-name').innerText = p.name;
            document.getElementById('rebuy-min').innerText = game.minBuyin;
            document.getElementById('rebuy-max').innerText = game.maxBuyin;
            document.getElementById('rebuy-amount').value = game.minBuyin;
            document.getElementById('modal-menu').classList.remove('open');
            document.getElementById('modal-rebuy').classList.add('open');
        }
        
        function confirmRebuy() {
    const amt = parseFloat(document.getElementById('rebuy-amount').value);
    
    // Validation
    if (isNaN(amt) || amt < 0) { 
        alert("Please enter a valid amount"); 
        return; 
    }

    const p = game.players[game.contextPlayerIdx];

    // --- THE FIX ---
    p.stack += amt;                           // 1. Add chips to current stack
    p.rebuyTotal = (p.rebuyTotal || 0) + amt; // 2. Add to Rebuy Total
    p.rebuyCount = (p.rebuyCount || 0) + 1;   // 3. Add to Rebuy Count
    
    // CRITICAL: We DO NOT touch p.buyInTotal here anymore.
    // It must stay as the INITIAL amount for the settlement math to work.

    // Auto sit-in logic
    p.sittingOut = false; 
    p.folded = false;
    p.isOnBreak = false;
    
    closeModal('modal-rebuy'); 
    openMenuModal(); 
    renderTable();
    
    if (typeof checkRestartHand === 'function') {
        checkRestartHand(p, amt);
    }
}
        
        function checkRestartHand(player, rebuyAmt) {
            if (game.street >= 0 && game.activePlayerIndex !== -1) {
                if(confirm("Restart current hand with updated stacks?")) {
                    restartHandWithNewStack(game.contextPlayerIdx, rebuyAmt);
                }
            }
        }
        
        function restartHandWithNewStack(playerIdx, addedAmount) {
             // MAJOR FIX: RESET STATE BASED ON CURRENT PLAYERS, NOT SNAPSHOT
             game.players.forEach(p => {
                 p.cards = [];
                 
                 // --- NEW FIX START ---
                 // If the player had a bet out (e.g. 1.20), restarting wipes it.
                 // We must lower their BuyInTotal by that amount so the math engine
                 // doesn't think those missing chips belong to the Pot.
                 if (p.currentBet > 0) {
                     p.buyInTotal -= p.currentBet; 
                     p.currentBet = 0;
                 }
                 // --- NEW FIX END ---

                 p.hasActed = false;
                 p.isChecked = false;
                 p.lastAction = "";
                 p.vpipThisHand = false;
                 p.hasPFRThisHand = false;
                 p.folded = p.sittingOut || p.isOnBreak;
                 
                 // Also reset the hand total tracker
                 p.handTotalBet = 0;
             });
             
             game.pot = 0;
             game.street = 0;
             game.boards = [[]];
             game.runoutCount = 1;
             game.activePlayerIndex = -1;
             game.currentHandReplay = [];
             game.preflopRaiseCount = 0;
             
             startHandLogic();
             
             closeModal('modal-menu'); 
             renderTable();
             saveReplayStep("Hand Restarted (Correction)");
        }

        function renamePlayer(i, val) { game.players[i].name = val; renderTable(); }
        
        function togglePlayerBreak(i) {
            const p = game.players[i];
            if (p.sittingOut) {
                if (p.stack <= 0) {
                    alert("Player has no chips. Please Rebuy first.");
                    openRebuyModal(i); return;
                }
                p.sittingOut = false;
                p.folded = false; 
            } else {
                p.isOnBreak = !p.isOnBreak;
                if(p.isOnBreak) { p.folded = true; }
            }
            openMenuModal(); renderTable();
        }
        
        function toggleAutoDetect() { game.autoWinner = !game.autoWinner; openMenuModal(); saveLocal(); }

        // --- UTILS & HELPERS ---
        function placeBetLogic(idx, amt, isBlind = false) {
    const p = game.players[idx];

    // 1. Label Logic
    let moveType = "BET";
    if (p.currentBet > 0 || isBlind) moveType = "RAISE"; 
    
    // Calculate table max
    let maxBet = 0; 
    game.players.forEach(pl => maxBet = Math.max(maxBet, pl.currentBet));
    const totalAfterBet = p.currentBet + amt;

    if(totalAfterBet === maxBet && !isBlind && amt > 0) moveType = "CALL";
    if (totalAfterBet > maxBet) moveType = "RAISE";

    // 2. Move Chips
    p.stack = parseFloat((p.stack - amt).toFixed(2));
    p.currentBet = parseFloat((p.currentBet + amt).toFixed(2));
    p.handTotalBet = parseFloat(((p.handTotalBet || 0) + amt).toFixed(2));
    
    // 3. Update Status
    p.hasActed = true; 
    p.isChecked = false;

    // --- MARKER LOGIC ONLY (NO MATH!) ---
    if (!isBlind && amt > 0) {
        
        // Mark VPIP (Just set the flag, do NOT count +1)
        p.hasVPIP = true;

        // Mark Aggression (Pre-Flop Only)
        if (game.street === 0) {
            if (moveType === "RAISE" || moveType === "BET") {
                
                // Mark PFR (Just set the flag)
                p.hasPFR = true;

                // Mark 3-Bet (Just set the flag)
                if (moveType === "RAISE" && maxBet > game.bb) {
                    p.has3Bet = true;
                }
            }
        }
    }
    // ------------------------------------

    // 4. Set Last Action String
    if(p.stack === 0) {
        p.lastAction = `ALL IN (${formatMoney(p.currentBet)})`;
    } else {
        if(isBlind) p.lastAction = (amt === game.sb) ? "SB" : "BB";
        else if(amt === 0) p.lastAction = "CHECK";
        else p.lastAction = `${moveType} ${formatMoney(p.currentBet)}`;
    }
}

function exportFullHistory() {
    const req = indexedDB.open(DB_NAME, 1);
    req.onsuccess = (e) => {
        const db = e.target.result;
        const tx = db.transaction('hands', 'readonly');
        const store = tx.objectStore('hands');
        const getAll = store.getAll();

        getAll.onsuccess = () => {
            const allHands = getAll.result;
            // Now use 'allHands' to generate your CSV 
            // instead of 'game.history'
            console.log("Total hands in storage:", allHands.length);
        };
    };
}


		// MASTER POT CALCULATOR: Ensures pot is always mathematically correct
// MASTER POT CALCULATOR: Ensures pot is always mathematically correct
function recalculateGlobalPot() {
     let totalMoneyInGame = 0;
     let moneyOnTable = 0;
     
     game.players.forEach(p => {
         // The total money committed by players so far in the tournament/session.
         // This is a global ledger for P&L, NOT for the current pot.
         totalMoneyInGame += (p.buyInTotal || 0) + (p.casualCorrection || 0);
         
         // Money currently held by players
         moneyOnTable += p.stack + p.currentBet;
     });
     
     // Account for "Pending Splash" (money removed from stack but not in pot yet)
     const pending = game.pendingSplash || 0;
     
     // The Pot MUST be whatever is left over
     const correctPot = totalMoneyInGame - moneyOnTable - pending;
     
     // Precision fix to prevent 100.00000001
     return parseFloat(correctPot.toFixed(2));
}

// MODIFIED: Added color assignment and fixed the final pot amount calculation logic
// MASTER POT CALCULATOR: Ensures pot is always mathematically correct
function calculatePotStructure() {
    // 1. Identify Active Players (Not folded, sitting out, or on break)
    const activePlayers = game.players.filter(p => !p.folded && !p.sittingOut && !p.isOnBreak);
    
    // Safety check
    if(activePlayers.length === 0) {
        let totalBetChips = 0;
        game.players.forEach(p => totalBetChips += p.currentBet);
        
        game.potStructure = [{ 
            amount: game.pot + totalBetChips, 
            eligible: game.players.filter(p => p.handTotalBet > 0), 
            colorClass: 'var(--pot-color-main)', 
            name: "Main Pot" 
        }];
        return game.potStructure;
    }

    // 2. Collect Bets and SORT ASCENDING
    let allBets = game.players.map(p => ({ 
        name: p.name, 
        bet: p.handTotalBet || 0, 
        playerObj: p 
    })).filter(b => b.bet > 0);

    let uniqueBets = [...new Set(allBets.map(b => b.bet))].sort((a,b) => a - b);
    
    let pots = [];
    let prevLevel = 0;

    // 3. Build Pots (Slices)
    uniqueBets.forEach(level => {
        let contribution = level - prevLevel;
        if(contribution <= 0.01) return; 

        let contributors = allBets.filter(b => b.bet >= level);
        let eligible = game.players.filter(p => (p.handTotalBet || 0) >= level);

        let sliceAmount = contribution * contributors.length;

        if (sliceAmount > 0.01) {
            pots.push({
                amount: sliceAmount,
                eligible: eligible,
                name: "", 
                colorClass: "" 
            });
        }
        prevLevel = level;
    });

    // 4. Merge Logic (Fix applied here)
    for(let i = pots.length - 1; i > 0; i--) {
        let current = pots[i]; // Higher bet level (Smaller group)
        let prev = pots[i-1];  // Lower bet level (Larger group)
        
        const currentNames = current.eligible.map(p => p.name).sort();
        const prevNames = prev.eligible.map(p => p.name).sort();
        
        const sameEligible = currentNames.length === prevNames.length && 
                             currentNames.every((name, index) => name === prevNames[index]);

        let shouldMerge = false;

        if (sameEligible) {
            shouldMerge = true;
        } else {
            // FIX: Check if the difference is caused by an ALL-IN player.
            // Identify players in the Lower Pot who did NOT reach the Higher Pot level.
            const droppedOutPlayers = prev.eligible.filter(p => !current.eligible.includes(p));

            // If ANY of these players are truly All-In (stack approx 0), we must keep the side pot.
            // If NONE are All-In (all have chips left), this is just a betting gap, so we MERGE.
            const hasAllInPlayer = droppedOutPlayers.some(p => p.stack < 0.01 && !p.folded);

            if (!hasAllInPlayer && droppedOutPlayers.length > 0) {
                shouldMerge = true;
            }
        }

        if(shouldMerge) {
            prev.amount = parseFloat((prev.amount + current.amount).toFixed(2));
            pots.splice(i, 1); 
        }
    }

    // 5. Assign Colors and Names
    const sideColors = [
        'var(--pot-color-side-1)', 
        'var(--pot-color-side-2)', 
        'var(--pot-color-side-3)', 
        'var(--pot-color-side-4)'  
    ];

    pots.forEach((pot, index) => {
        if (index === 0) {
            pot.name = "Main Pot";
            pot.colorClass = 'var(--pot-color-main)'; 
        } else {
            pot.name = `Side Pot ${index}`;
            pot.colorClass = sideColors[(index - 1) % sideColors.length];
        }
    });
    
    // 6. Mathematical Verification (Cleanup display rounding errors)
    let totalPotAmount = game.pot;
    game.players.forEach(p => totalPotAmount += p.currentBet);
    let calculatedSum = pots.reduce((sum, pot) => sum + pot.amount, 0);

    const diff = parseFloat((totalPotAmount - calculatedSum).toFixed(2));
    if (diff !== 0 && pots.length > 0) {
            pots[0].amount = parseFloat((pots[0].amount + diff).toFixed(2));
    }
    
    game.potStructure = pots;
    return pots;
}
        // 1. OPTIMIZED UNDO: Stops RAM explosion
function pushUndoState() {
    // 1. Safety initialization: Ensure these exist BEFORE we try to use them
    if (!game.undoStack) game.undoStack = [];
    if (!game.redoStack) game.redoStack = [];

    // 2. Create a "Light" snapshot
    const snapshot = JSON.parse(JSON.stringify(game, (key, value) => {
        if (key === 'undoStack') return undefined; // Prevent infinite loop
        if (key === 'history') return undefined;   // History is huge; don't save it in undo
        return value;
    }));

    // 3. Push to stack
    game.undoStack.push(snapshot); 
    
    // 4. Memory management
    if(game.undoStack.length > 10) game.undoStack.shift(); 
    
    // 5. Clear Redo because a new action was taken
    game.redoStack = [];
}

// 2. OPTIMIZED RESTORE: Handles the missing history from above
function undoLastAction() { 
    if (game.winnerTimeout) { clearTimeout(game.winnerTimeout); game.winnerTimeout = null; }

    if(game.undoStack.length > 0) { 
        // 1. Hold onto the REAL history (since we deleted it from the snapshot)
        const currentHistory = game.history; 
        
        const prevState = game.undoStack.pop();
        
        // 2. Restore the game state
        Object.assign(game, prevState);
        
        // 3. Re-attach the history
        game.history = currentHistory;
        
        // 4. Force calculation fixes
        game.pot = recalculateGlobalPot();

        // 5. Close any open modals that might be stuck
        document.getElementById('modal-winner').classList.remove('open');
        document.getElementById('modal-bust').classList.remove('open');
        document.getElementById('modal-bet').classList.remove('open');
        document.getElementById('modal-cards').classList.remove('open');
        document.getElementById('modal-manual-win').classList.remove('open');

        renderTable(); 
        saveLocal(); // Save the clean state
    } else { 
        alert("Nothing to undo!"); 
    }
}
        
        function getUsedCards() { 
            let used = new Set(); 
            if(game.players) game.players.forEach(p => { if(p.cards) p.cards.forEach(c => used.add(c)) }); 
            if(game.isSelectingBoard && game.runoutCount > 1) {
                game.workingBoards.forEach((wb, i) => {
                     if (i !== game.editBoardIndex) wb.forEach(c => used.add(c));
                });
            } else if (!game.isSelectingBoard) {
                 game.boards.forEach(b => b.forEach(c => used.add(c)));
            }
            return used; 
        }
        
        let curSuit = 's';
        function openHandSelector() { 
            if(game.activePlayerIndex>-1){ 
                game.isSelectingBoard=false; 
                game.tempCards = [...(game.players[game.activePlayerIndex].cards || [])]; 
                document.getElementById('rimt-modal-tabs').style.display = 'none'; 
                document.getElementById('modal-board-controls').style.display = 'none'; 
                updateCardPrev(); renderRankGrid(); 
                document.getElementById('card-modal-title').innerText = `Select Cards: ${game.players[game.activePlayerIndex].name}`;
                document.getElementById('modal-cards').classList.add('open'); 
            } 
        }
        
        function openBoardSelector() { 
            game.isSelectingBoard=true; 
            game.workingBoards = JSON.parse(JSON.stringify(game.boards));
            game.editBoardIndex = game.viewingBoardIndex;
            game.tempCards = [...(game.workingBoards[game.editBoardIndex] || [])]; 
            document.getElementById('modal-board-controls').style.display = 'flex';
            document.getElementById('modal-street-select').value = game.street;
            document.getElementById('modal-rimt-select').value = game.runoutCount;
            renderModalTabs(); updateCardPrev(); renderRankGrid(); 
            document.getElementById('card-modal-title').innerText = "Select Board"; 
            document.getElementById('modal-cards').classList.add('open'); 
        }
        
        function updateModalStreet() {
            const s = parseInt(document.getElementById('modal-street-select').value);
            game.street = s;
            document.getElementById('street-name').innerText = streets[s]; 
            renderRankGrid();
        }
        
        function updateModalRIMT() {
            const n = parseInt(document.getElementById('modal-rimt-select').value);
            const currentMainBoard = [...game.tempCards];
            game.runoutCount = n;
            while(game.workingBoards.length < n) {
                game.workingBoards.push([...currentMainBoard]); 
            }
            if(game.workingBoards.length > n) {
                game.workingBoards = game.workingBoards.slice(0, n);
            }
            if(game.editBoardIndex >= n) {
                game.editBoardIndex = 0;
                game.tempCards = [...game.workingBoards[0]];
                updateCardPrev();
            }
            renderModalTabs();
        }
       function returnUncalledBets() {
            // Filter players who have money in front (including folded players)
            const bettors = game.players.filter(p => p.currentBet > 0);
            if(bettors.length === 0) return;

            // Sort bets descending (Highest first)
            bettors.sort((a, b) => b.currentBet - a.currentBet);

            const highBettor = bettors[0];
            const maxBet = highBettor.currentBet;
            
            // Find the cap (2nd highest bet). If no one else, cap is 0.
            let cap = 0;
            if (bettors.length > 1) {
                cap = bettors[1].currentBet;
            }

            if (maxBet > cap) {
                const refund = maxBet - cap;
                
                // 1. Refund the player
                highBettor.stack += refund;
                highBettor.currentBet -= refund; 
                highBettor.handTotalBet -= refund;

                // 2. Precision Safety
                highBettor.stack = parseFloat(highBettor.stack.toFixed(2));
                highBettor.currentBet = parseFloat(highBettor.currentBet.toFixed(2));
                highBettor.handTotalBet = parseFloat(highBettor.handTotalBet.toFixed(2));
                
                // NOTE: We do NOT subtract from game.pot here, as currentBet isn't in pot yet.
                
                saveReplayStep(`Refund: Returned ${formatMoney(refund)} to ${highBettor.name} (Uncalled)`);
            }
        }

        // --- MISSING FUNCTION ADDED BELOW ---
        function renderModalTabs() {
            const tabsDiv = document.getElementById('rimt-modal-tabs');
            if (game.runoutCount > 1) {
                tabsDiv.innerHTML = "";
                tabsDiv.style.display = 'flex';
                for(let i=0; i<game.runoutCount; i++) {
                    const tab = document.createElement('div');
                    tab.className = `rimt-tab ${i === game.editBoardIndex ? 'active' : ''}`;
                    tab.innerText = `Run ${i+1}`;
                    tab.onclick = () => switchModalTab(i);
                    tabsDiv.appendChild(tab);
                }
            } else {
                tabsDiv.style.display = 'none';
            }
        }
        
        function switchModalTab(idx) {
            game.workingBoards[game.editBoardIndex] = [...game.tempCards];
            game.editBoardIndex = idx;
            game.tempCards = [...(game.workingBoards[idx] || [])];
            renderModalTabs();
            updateCardPrev(); renderRankGrid();
        }

        function setSuit(s){ curSuit=s; document.querySelectorAll('.suit-btn').forEach(b=>b.classList.remove('selected')); event.target.classList.add('selected'); renderRankGrid(); }
        
        function renderRankGrid() {
            const grid = document.getElementById('rank-grid'); grid.innerHTML = ""; 
            const used = getUsedCards();
            let limit = 0;
            
            if (game.isSelectingBoard) {
                if (game.street === 0) limit = 0;
                else if (game.street === 1) limit = 3;
                else if (game.street === 2) limit = 4;
                else if (game.street === 3) limit = 5;
            } else { 
                // FIX: Check Game Mode for Player Card Limit
                // If PLO or Bomb Pot, allow 4 cards. Else 2.
                limit = (game.gameMode === 'plo' || game.isBombPot) ? 4 : 2; 
            }
            
            ranks.forEach(r => {
                const code = r + curSuit; 
                const isUsed = used.has(code) && !game.tempCards.includes(code); 
                const isSelected = game.tempCards.includes(code);
                const btn = document.createElement('button'); 
                btn.className = `rank-btn ${isUsed ? 'disabled' : ''}`; 
                btn.style.borderColor = isSelected ? 'var(--accent-gold)' : '#444'; 
                btn.innerText = r;
                btn.onclick = () => { 
                    if(isUsed) return;
                    if(game.tempCards.includes(code)) { 
                        game.tempCards = game.tempCards.filter(c => c !== code); 
                    } else { 
                        if(game.tempCards.length >= limit) return; 
                        game.tempCards.push(code); 
                    } 
                    updateCardPrev(); renderRankGrid(); 
                };
                grid.appendChild(btn);
            });
        }
        function updateCardPrev(){ let h=""; game.tempCards.forEach(c => h += createCardHTML(c)); document.getElementById('card-preview').innerHTML=h; }
        
        function confirmCards(){ 
            pushUndoState(); 
            if(game.isSelectingBoard) { 
                game.workingBoards[game.editBoardIndex] = [...game.tempCards];
                game.boards = JSON.parse(JSON.stringify(game.workingBoards));
                game.viewingBoardIndex = game.editBoardIndex;
                saveReplayStep(`Board Updated`); 
            } 
            else if(game.activePlayerIndex>-1) { game.players[game.activePlayerIndex].cards=[...game.tempCards]; } 
            
            closeModal('modal-cards'); renderTable(); 
            
            // 1. CHECK IF PLAYERS STILL NEED CARDS
            // Only care about this if we are in the "Input Loop" (isShowdownEntry)
            const activePlayersMissingCards = game.players.some(p => !p.folded && !p.sittingOut && !p.isOnBreak && p.cards.length === 0);
            
            if (activePlayersMissingCards && game.isShowdownEntry) {
                setTimeout(startShowdownEntry, 300);
                return; // Stop here, continue loop
            } 
            
            // 2. CHECK IF WE CAN AUTO-WIN
            // Condition: Bomb Pot OR (River + AutoWin is ON)
            if (game.isBombPot || (game.street === 4 && game.autoWinner)) {
                
                // Are boards ready?
                let boardsReady = true;
                for(let i=0; i<game.runoutCount; i++) {
                    if(!game.boards[i] || game.boards[i].length < 5) boardsReady = false;
                }
                
                // If everyone has cards AND boards are ready -> GO
                if (!activePlayersMissingCards && boardsReady) {
                    setTimeout(performAutoShowdown, 300);
                }
                // Fail-safe: If Auto-Win is ON, but boards are missing, 
                // we do NOTHING (don't alert constantly). 
                // The user will tap the board, fill it, and THIS function runs again.
            }
        }

        function openActionModal() { 
            if(!validateBoardState()) { alert(`Please input all necessary Board Cards first!`); openBoardSelector(); return; }
            if(game.activePlayerIndex>-1) { 
                game.tempBet="0"; game.isAddMode=false; 
                document.getElementById('current-bet-display').innerText=formatMoney(game.players[game.activePlayerIndex].currentBet); 
                document.getElementById('bet-input-display').innerText="0"; 
                document.getElementById('modal-bet').classList.add('open'); 
            }
        }
        function addMode() { game.isAddMode = true; document.getElementById('bet-input-display').innerText = "+ " + game.tempBet; }
        function numInput(v) { if(v==='.'){ if(!game.tempBet.includes('.')) game.tempBet+='.'; } else { game.tempBet = game.tempBet==="0"?String(v):game.tempBet+v; } let display = game.tempBet; if(game.isAddMode) display = "+ " + display; document.getElementById('bet-input-display').innerText = display; }
        function adjustBet(direction) {
            let current = parseFloat(game.tempBet) || 0; let step = game.betIncrement || 0.25;
            let newVal = current + (step * direction); if(newVal < 0) newVal = 0;
            game.tempBet = formatMoney(newVal).toString();
            let display = game.tempBet; if(game.isAddMode) display = "+ " + display; document.getElementById('bet-input-display').innerText = display;
        }
        function backspaceBet() {
            if(game.tempBet.length > 0) {
                game.tempBet = game.tempBet.slice(0, -1);
                if(game.tempBet === "") game.tempBet = "0";
            }
            let display = game.tempBet; if(game.isAddMode) display = "+ " + display; document.getElementById('bet-input-display').innerText = display;
        }
        function quickPotBet() { game.tempBet = String(game.pot); game.isAddMode = true; document.getElementById('bet-input-display').innerText = "+ " + game.tempBet; }
        
        function selectPlayer(i) { 
             if(game.street === 4) { 
                 game.activePlayerIndex = i; 
                 renderTable(); 
             } 
             else if(!game.paused && !game.players[i].sittingOut && !game.players[i].isOnBreak) { 
                 game.activePlayerIndex = i; 
                 if(!game.players[i].folded) { startTurnTimer(); }
                 renderTable(); 
             }
        }
        
        function handleCardButton() {
            if (game.activePlayerIndex !== -1) { openHandSelector(); } else { openBoardSelector(); }
        }

        function saveReplayStep(t) { 
            game.currentHandReplay.push({ 
                text: t, 
                pot: game.pot, 
                board: JSON.parse(JSON.stringify(game.boards)), 
                players: game.players.map(p => ({ name: p.name, stack: p.stack, bet: p.currentBet, folded: p.folded, nitCharges: p.nitCharges })) 
            }); 
        }
        
			function openReplay(handId) {
    const req = indexedDB.open('PokerHistoryDB', 1);
    req.onsuccess = (e) => {
        const db = e.target.result;
        const tx = db.transaction('hands', 'readonly');
        const store = tx.objectStore('hands');
        const getHand = store.get(handId);

        getHand.onsuccess = () => {
            const fullData = getHand.result;
            if (fullData) {
                // Now launch your Replay Modal using fullData.replayData
                launchReplayUI(fullData);
            }
        };
    };
}

			function replayStep(d) { const n = game.replayIndex + d; if(n >= 0 && n < game.activeReplayHand.length) { game.replayIndex = n; renderReplayStep(); } }
        
		function loadReplay(identifier) {
    // 1. Force the ID to be a Number (Crucial for IndexedDB lookup)
    const handId = Number(identifier);

    // 2. Open using the CORRECT VERSION (2)
    const req = indexedDB.open(DB_NAME, DB_VERSION);

    req.onsuccess = (e) => {
        const db = e.target.result;
        const tx = db.transaction('hands', 'readonly');
        const store = tx.objectStore('hands');
        
        // 3. Fetch the full hand data
        const getHand = store.get(handId);

        getHand.onsuccess = () => {
            const hand = getHand.result;

            if (!hand || !hand.replayData) {
                console.error("Replay Data not found for ID:", handId);
                alert("Replay data not found for Hand #" + handId);
                return;
            }

            // 4. Load data into memory
            game.activeReplayHand = hand.replayData;
            game.replayIndex = 0;
            game.currentVisibleReplayDoc = hand; 

            document.getElementById('replay-hand-id').innerText = hand.id;

            // 5. Switch UI
            document.getElementById('modal-menu').classList.remove('open');
            document.getElementById('modal-replay').classList.add('open');

            renderReplayStep();
        };
    };
    
    req.onerror = (err) => {
        console.error("Database connection error:", err.target.error);
        alert("Database Error: Make sure you are using Version 2 of the DB.");
    };
}
		
function renderReplayStep() {
    const step = game.activeReplayHand[game.replayIndex];
    
    // Get Dealer Index from History
    // Pull dealer info from the temporary doc we loaded from IndexedDB
	const dealerIdx = (game.currentVisibleReplayDoc) ? game.currentVisibleReplayDoc.dealerIdx : -1;
    
    const totalPlayers = step.players.length;
    const container = document.getElementById('replay-stage'); 

    document.getElementById('replay-pot').innerText = formatMoney(step.pot); 
    
    // --- LOG DISPLAY (Unchanged) ---
    const logDiv = document.getElementById('replay-log-text');
    logDiv.innerHTML = ""; 

    if(step.winners && step.winners.length > 0) {
        logDiv.style.color = "white"; 
        logDiv.style.fontSize = "12px";
        
        let html = `<div style="background:rgba(0,0,0,0.5); border:1px solid #444; border-radius:6px; padding:8px; display:inline-block; min-width:240px; text-align:left;">`;
        html += `<div style="color:var(--accent-green); font-weight:bold; text-align:center; margin-bottom:6px; border-bottom:1px solid #444; padding-bottom:4px; font-size:11px; letter-spacing:1px;">HAND RESULTS</div>`;
        
        step.winners.forEach((w, idx) => {
            let potLabel;
            let potColor;
            if (step.winners.length === 1 || idx === step.winners.length - 1) {
                potLabel = "Main Pot"; potColor = 'var(--pot-color-main)';
            } else {
                const sidePotIndex = step.winners.length - 1 - idx; 
                potLabel = `Side Pot ${sidePotIndex}`;
                const sideColors = ['var(--pot-color-side-1)', 'var(--pot-color-side-2)', 'var(--pot-color-side-3)', 'var(--pot-color-side-4)'];
                potColor = sideColors[(sidePotIndex - 1) % sideColors.length];
            }
            const borderStyle = idx === step.winners.length - 1 ? "" : "border-bottom:1px dashed #333; margin-bottom:6px; padding-bottom:6px;";
            html += `<div style="${borderStyle}"><div style="display:flex; justify-content:space-between; align-items:center;"><span style="color:#888; font-size:10px; text-transform:uppercase;">${potLabel}</span><span style="color:var(--accent-green); font-weight:bold;">+${formatMoney(w.amt)}</span></div><div style="display:flex; justify-content:space-between; align-items:center; margin-top:2px;"><span style="font-weight:bold; font-size:13px; color:${potColor}">${w.name}</span><span style="font-size:10px; color:var(--accent-gold); font-style:italic;">${w.hand || ''}</span></div></div>`;
        });
        html += `</div>`;
        logDiv.innerHTML = html;
    } else {
        logDiv.innerText = step.text;
        if(step.text.includes("Winner")) { logDiv.style.color = "var(--accent-green)"; logDiv.style.fontSize = "16px"; }
        else { logDiv.style.color = "#aaa"; logDiv.style.fontSize = "14px"; }
    }
    
    // --- 1. POT VISUALS (Unchanged) ---
    const oldPot = container.querySelector('.pot-visual');
    if(oldPot) oldPot.remove(); 
    let potStyle = "top: 30%; left: 50%; transform: translate(-50%, -50%);"; 
    if(step.winners && step.winners.length === 1) {
        const wName = step.winners[0].name;
        const wIdx = step.players.findIndex(p => p.name === wName);
        if(wIdx !== -1) {
            const angle = (wIdx / totalPlayers) * 2 * Math.PI + (Math.PI / 2);
            const xPos = 50 + 35 * Math.cos(angle - Math.PI/2); 
            const yPos = 50 + 35 * Math.sin(angle - Math.PI/2);
            potStyle = `top: ${yPos}%; left: ${xPos}%; transform: translate(-50%, -50%);`;
        }
    }
    if(step.pot > 0) {
         let html = getChipHtml(step.pot);
         html = html.replace('class="chip-row"', 'class="chip-row-pot" style="display:flex; align-items:flex-end; gap:2px;"');
         container.innerHTML += `<div class="pot-visual" style="${potStyle}">${html}</div>`;
    }

    // --- 2. BOARD CARDS (Unchanged) ---
    const rbDiv = document.getElementById('replay-board');
    rbDiv.innerHTML = ""; 
    if (Array.isArray(step.board) && Array.isArray(step.board[0])) {
        step.board.forEach((run, rIdx) => {
            if(run.length > 0) {
                let h = ""; run.forEach(c => h += createCardHTML(c));
                const runContainer = document.createElement('div');
                runContainer.className = 'runout-container';
                if(step.board.length > 1) runContainer.innerHTML = `<div class="runout-label" style="color:#ccc">Run ${rIdx+1}</div><div class="board-cards-container">${h}</div>`;
                else runContainer.innerHTML = `<div class="board-cards-container">${h}</div>`;
                rbDiv.appendChild(runContainer);
            }
        });
    } else if (Array.isArray(step.board)) {
        let bHtml = ""; step.board.forEach(c => bHtml += createCardHTML(c)); 
        rbDiv.innerHTML += `<div class="board-cards-container">${bHtml}</div>`;
    }
    
    // --- 3. PLAYERS (Visual Fixes Here) ---
    const players = container.querySelectorAll('.replay-player'); players.forEach(p => p.remove());
    const winnerNames = step.winners ? step.winners.map(w => w.name) : [];
    const isLastStep = (game.replayIndex === game.activeReplayHand.length - 1);

    step.players.forEach((p, i) => {
        const el = document.createElement('div'); el.className = `replay-player ${p.folded ? 'folded' : ''}`;
        if(winnerNames.includes(p.name)) el.classList.add('winner');
        
        const angle = (i / totalPlayers) * 2 * Math.PI + (Math.PI / 2);
        const xPos = 50 + 42 * Math.cos(angle - Math.PI/2); 
        const yPos = 50 + 42 * Math.sin(angle - Math.PI/2);
        el.style.left = xPos + "%"; el.style.top = yPos + "%"; el.style.transform = "translate(-50%, -50%)";
        
        let cardHtml = "";
        if(p.folded) cardHtml = ""; 
        else if(step.showdown) {
            const playerData = step.showdown.find(s => s.idx === i);
            if(playerData && playerData.cards) playerData.cards.forEach(c => cardHtml += createMiniCardHTML(c));
        } else {
            cardHtml = createCardBackHTML(true) + createCardBackHTML(true);
        }

        // --- NEW: Casual Mode Visibility Logic ---
        // 1. DEFAULT: Show actual stack (for Bookkeeper Mode)
        let displayStack = `‚Ç¨${formatMoney(p.stack)}`;
        let showChips = true;

        // 2. CHECK: Only override if Casual Mode is ON
        if (game.lazyMode) {
            // FIX #1: Check absolute value. Negative stack != All In.
            if (Math.abs(p.stack) > 0.01) {
                // Hide stack if they still have chips (positive or negative)
                displayStack = `<span style="color:#777; font-size:9px;">(---)</span>`;
                showChips = false; 
            } else {
                // Only show "ALL IN" if they are truly at 0
                displayStack = `<span style="color:var(--accent-red); font-size:9px; font-weight:bold;">ALL IN</span>`;
            }
        }

        // Chips
        let stackChipsHtml = "";
        if (!p.folded && showChips) {
             stackChipsHtml = getChipHtml(p.stack);
        }
        
        let betChipsHtml = "";
        if (p.bet > 0) {
            betChipsHtml = getChipHtml(p.bet);
            betChipsHtml = betChipsHtml.replace('class="chip-row"', 'class="chip-row-bet"');
        }
        
        // SKULL / ALL-IN LOGIC
        let statusIcon = "";
        // FIX #2: Check absolute value here too. Don't show skull for negative stacks.
        if (!p.folded && Math.abs(p.stack) < 0.01) {
            if (isLastStep) {
                 statusIcon = `<div class="skull-icon">üíÄ</div>`;
            } else {
                 statusIcon = `<div class="all-in-triangle"></div>`;
            }
        }

        // Dealer Button
        let dealerHtml = (i === dealerIdx) ? `<div class="dealer-btn-large">D</div>` : "";

        el.innerHTML = `
            ${dealerHtml}
            ${statusIcon}
            ${p.bet > 0 ? `<div class="replay-action-pill">${formatMoney(p.bet)}</div>` : ''}
            <div>${p.name}</div>
            <div style="color:var(--accent-green)">${displayStack}</div>
            <div class="replay-cards">${cardHtml}</div>
            ${stackChipsHtml}
            ${betChipsHtml}
        `;
        container.appendChild(el);
    });
}
        
        function switchTab(t, btn) { 
            document.querySelectorAll('.tab-content').forEach(c=>c.classList.remove('active')); 
            document.querySelectorAll('.tab-btn').forEach(b=>b.classList.remove('active')); 
            document.getElementById(t).classList.add('active'); if(btn) btn.classList.add('active');
            if (t === 'tab-stats') renderStats(sortColumn.basic, 'basic');
            if (t === 'tab-advanced') renderStats(sortColumn.advanced, 'advanced');
        }
		function renderHistoryList() {
    const listContainer = document.getElementById('history-list');
    listContainer.innerHTML = "";
    
    if(!game.historyPlayerFilter) game.historyPlayerFilter = 'all';

    // --- FILTER LOGIC (Standard) ---
    const filtered = game.history.filter(h => {
        let matchesType = true;
        const filter = game.historyFilter;
        const threshold = game.bigPotThreshold || 50;

        if (filter === 'fav' && !h.favorite) matchesType = false;
        if (filter === 'bomb' && !h.isBombPot) matchesType = false;
        if (filter === 'bigpot' && (h.potValue < threshold)) matchesType = false;
        if (filter === 'showdown') {
            const hasShowdown = h.replayData && h.replayData.some(step => step.showdown && step.showdown.length > 0);
            if (!hasShowdown) matchesType = false;
        }
        if (filter === 'allin') {
            const hadAllIn = h.playerState && h.playerState.some(p => p.stack === 0 && !p.folded);
            if (!hadAllIn) matchesType = false;
        }
        if (filter === 'bust') {
             const hadBust = h.playerState && h.playerState.some(p => p.stack === 0);
             if (!hadBust) matchesType = false;
        }
        let matchesPlayer = true;
        if (game.historyPlayerFilter !== 'all') {
            const pState = h.playerState ? h.playerState.find(p => p.name === game.historyPlayerFilter) : null;
            if (!pState || pState.sittingOut) matchesPlayer = false;
            else {
                if (filter === 'showdown' && pState.folded) matchesPlayer = false;
                if (filter === 'allin' && pState.stack > 0) matchesPlayer = false;
                if (filter === 'bust' && pState.stack > 0) matchesPlayer = false;
            }
        }
        return matchesType && matchesPlayer;
    });

    if(filtered.length === 0) {
        listContainer.innerHTML = `<div style="text-align:center; padding:20px; color:#666;">No hands found matching filters.</div>`;
        return;
    }

    // Newest First
    const displayList = [...filtered].reverse();

    displayList.forEach(h => {
        let badgesHtml = "";
        if (h.isBombPot) badgesHtml += `<span style="font-size:10px; margin-left:4px; border:1px solid #e74c3c; color:#e74c3c; border-radius:4px; padding:2px 4px;">üí£ Bomb</span>`;
        if (h.potValue >= (game.bigPotThreshold || 50)) badgesHtml += `<span style="font-size:10px; margin-left:4px; border:1px solid gold; color:gold; border-radius:4px; padding:2px 4px;">üí∞ Big Pot</span>`;
        
        const isShowdown = h.replayData && h.replayData.some(s => s.showdown);
        if (isShowdown) badgesHtml += `<span style="font-size:10px; margin-left:4px; border:1px solid #55aaff; color:#55aaff; border-radius:4px; padding:2px 4px;">üÉè SD</span>`;

        // --- HELPER TO CONVERT DATA FOR YOUR FUNCTION ---
        const getCardHTML = (c) => {
            // If it's an object {rank:'A', suit:'h'}, make it "Ah"
            let str = (typeof c === 'object' && c.rank) ? (c.rank + c.suit) : c;
            // Now call YOUR existing function
            return createMiniCardHTML(str);
        };

        // --- PLAYER CARDS ---
        let cardInfo = "";
        if(h.playerState) {
            h.playerState.forEach(p => {
                if((p.cards && p.cards.length > 0) || (p.nitCharges && p.nitCharges > 0)) {
                    let cHtml = ""; 
                    if(p.cards) p.cards.forEach(c => cHtml += getCardHTML(c));
                    
                    let nHtml = "";
                    if(p.nitCharges > 0) { for(let n=0; n<p.nitCharges; n++) nHtml += `<span style="color:#e74c3c; font-size:10px;">‚óè</span>`; }

                    const isSelectedPlayer = p.name === game.historyPlayerFilter;
                    const bgStyle = isSelectedPlayer ? 'background:rgba(255,255,255,0.1); border-radius:4px; padding:2px;' : '';

                    cardInfo += `<div class="hand-line" style="${bgStyle} display:flex; justify-content:space-between; align-items:center; margin-bottom:2px;">
                        <div style="font-size:12px;"><span>${p.name}:</span> ${nHtml}</div> 
                        <div class="mini-cards" style="display:flex; gap:2px;">${cHtml}</div>
                    </div>`;
                }
            });
        }
        
        // --- BOARD CARDS ---
        let bHtml = ""; 
        if(Array.isArray(h.board) && Array.isArray(h.board[0])) {
             h.board.forEach((run, idx) => {
                 if(run.length > 0) {
                    bHtml += (h.board.length > 1 ? `<span style="color:#888; font-size:10px;">R${idx+1}:</span> ` : '');
                    run.forEach(c => bHtml += getCardHTML(c));
                    bHtml += " ";
                 }
             });
        } else if (Array.isArray(h.board)) {
            h.board.forEach(c => bHtml += getCardHTML(c));
        }

        let wHtml = ""; 
        if(h.winners) h.winners.forEach(w => wHtml += `<div class="winner-line" style="color:#4CAF50; font-size:12px;"><span>${w.name}</span> <span style="font-weight:bold;">+${formatMoney(w.amt)}</span></div>`);
        
        const isFav = h.favorite ? "active" : ""; 
        const favIcon = h.favorite ? "‚òÖ" : "‚òÜ";
        
        listContainer.innerHTML += `
        <div class="history-item ${h.favorite ? 'favorite' : ''}" style="border-bottom:1px solid #333; padding:10px 0;">
            <div class="history-header" style="display:flex; justify-content:space-between; margin-bottom:5px;">
                <div style="display:flex; align-items:center; flex-wrap:wrap;">
                    <span style="color:#888; font-size:11px; margin-right:5px;">#${h.id}</span> ${badgesHtml}
                </div>
                <div style="display:flex; gap:10px; align-items:center;">
                    <button class="btn-fav ${isFav}" style="background:none; border:none; color:${h.favorite?'gold':'#555'}; cursor:pointer;" onclick="toggleFavorite(${game.history.indexOf(h)}); renderHistoryList();">${favIcon}</button>
                    <span style="color:#666; font-size:10px;">${h.time || ''}</span>
                </div>
            </div>
            
            <div class="history-board" style="margin-bottom:5px;">${bHtml || '<span style="color:#666; font-size:11px;">[No Board]</span>'}</div>
            <div class="history-winners" style="margin-bottom:5px;">${wHtml}</div>
            <div class="history-hands" style="background:#1a1a1a; padding:5px; border-radius:4px;">${cardInfo || '<span style="color:#444; font-size:10px;">No showdown cards</span>'}</div>
            
            <div style="padding-top:5px; text-align:right;">
                <button class="btn" style="background:#444; padding:4px 12px; font-size:11px; border-radius:12px;" onclick="loadReplay(${h.id})">Replay Hand</button>
            </div>
        </div>`;
    });
}
        
        function setHistoryFilter(val) {
            game.historyFilter = val;
            renderHistoryList();
        }
        // 3. OPTIMIZED SAVE: Prevents Storage Crash
function saveLocal() { 
    try {
        // Create a 'Clean' version for the phone storage
        const saveState = JSON.parse(JSON.stringify(game, (key, value) => {
            // CRITICAL: Never save the Undo Stack to disk.
            // It is huge (megabytes) and causes the "Quota Exceeded" crash.
            if (key === 'undoStack') return undefined;
            return value;
        }));
        
        localStorage.setItem('pV42', JSON.stringify(saveState));
    } catch (e) {
        console.error("Auto-save warning:", e);
        // If storage is full, try clearing old history to save the current hand
        if(game.history.length > 50) {
            game.history = game.history.slice(0, 50); // Trim history
        }
    }
}
        function restoreGame() { 
    const s = localStorage.getItem('pV42'); 
    if(s) { 
        try {
            game = JSON.parse(s); 
            
            // --- CRITICAL FIX: Repair Undo System ---
            if (!game.undoStack) game.undoStack = [];
            if (!game.redoStack) game.redoStack = [];
            
            // --- 1. SYSTEM REPAIRS (Boards & State) ---
            if(!game.boards) game.boards = [game.board || []];
            if(!game.runoutCount) game.runoutCount = 1;
            if(!game.viewingBoardIndex) game.viewingBoardIndex = 0;
            if(game.lazyMode === undefined) game.lazyMode = false; 
            
            // --- 2. PLAYER REPAIRS (Stats & Financials) ---
            if(game.players) {
                game.players.forEach(p => { 
                    if(p.buyInTotal === undefined) p.buyInTotal = p.stack; 
                    if(p.rebuyTotal === undefined) p.rebuyTotal = 0;
                    if(p.rebuyCount === undefined) p.rebuyCount = 0;
                    if(p.casualCorrection === undefined) p.casualCorrection = 0;
                    if(p.isOnBreak === undefined) p.isOnBreak = false;
                    if(p.lastAction === undefined) p.lastAction = ""; 
                    if(p.nitCount === undefined) p.nitCount = 0;
                    if(p.nitCharges === undefined) p.nitCharges = 0;
                    if(p.sevenDeuceWins === undefined) p.sevenDeuceWins = 0;
                    if(p.bombPotWins === undefined) p.bombPotWins = 0;
                    if(p.totalTime === undefined) p.totalTime = 0;
                    if(p.totalDecisions === undefined) p.totalDecisions = 0;
                    if(p.pfrHands === undefined) p.pfrHands = 0;
                    if(p.threeBetHands === undefined) p.threeBetHands = 0;
                    if(p.postFlopAggressiveActions === undefined) p.postFlopAggressiveActions = 0;
                    if(p.postFlopOpportunities === undefined) p.postFlopOpportunities = 0;
                    if(p.showdownHands === undefined) p.showdownHands = 0;
                    if(p.showdownWins === undefined) p.showdownWins = 0;
                    if(p.winWithoutShowdown === undefined) p.winWithoutShowdown = 0;
                });
            }
            
            if(game.history) game.history.forEach(h => { if(h.favorite === undefined) h.favorite = false; });
            if(game.autoWinner === undefined) game.autoWinner = false;
            if(game.nitSettings === undefined) game.nitSettings = { mode: 'splash', amount: 5, doubleNit: false };
            if(game.isBombPot === undefined) game.isBombPot = false;
            if(game.gameMode === undefined) game.gameMode = 'he';

            // --- 4. UI RESTORE ---
            document.getElementById('view-setup').classList.remove('active'); 
            document.getElementById('view-game').classList.add('active'); 
            
            if (typeof recalculateGlobalPot === 'function') {
                game.pot = recalculateGlobalPot(); 
            }
            
            renderTable(); 
            startGlobalTimer(); 
            console.log("Game successfully restored and repaired.");
            
        } catch(e) { 
            console.error("Restore Error:", e); 
            alert("Save file corrupted or incompatible."); 
        }
    }
}
        function closeModal(id) { document.getElementById(id).classList.remove('open'); }
        function modStack(i,v) { 
             game.players[i].stack+=v; game.players[i].buyInTotal+=v; 
             if (v > 0) game.players[i].rebuyTotal = (game.players[i].rebuyTotal||0) + v;
             openMenuModal(); renderTable(); 
        }
        function kick(i) { if(confirm("Kick?")) { game.players.splice(i,1); openMenuModal(); renderTable(); }}
        function addNewPlayer() { game.players.push({name:"New",stack:20,buyInTotal:20, rebuyTotal: 0, folded:true,sittingOut:false,isStanding:false, nitCharges: 0, isOnBreak:false,cards:[],currentBet:0,totalHands:0,vpipHands:0,totalTime:0,totalDecisions:0,nitCount:0, pfrHands:0, threeBetHands:0, showdownHands:0, showdownWins:0, postFlopAggressiveActions: 0, postFlopOpportunities: 0, winWithoutShowdown: 0}); openMenuModal(); renderTable(); }
        function formatMoney(n) { return n%1===0 ? n : n.toFixed(2); }
        function getChipHtml(amt) {
            if(amt <= 0) return "";
            
            let rem = amt;
            let chips = [];
            
            const add = (val, cls) => {
                const count = Math.floor(rem / val);
                for(let i=0; i<count; i++) chips.push(cls);
                rem = parseFloat((rem % val).toFixed(2));
            };
            
            add(100, 'black');
            add(25, 'green');
            add(5, 'red');
            add(1, 'blue');
            
            // FIX: If there is remaining change (e.g. 0.20, 0.50), add a White chip
            if (rem > 0) chips.push('white'); 

            if(chips.length > 40) chips = chips.slice(0, 40); 
            
            // Build Stacks (Columns of 5)
            let html = '<div class="chip-row">';
            let stackSize = 5;
            for (let i = 0; i < chips.length; i += stackSize) {
                const chunk = chips.slice(i, i + stackSize);
                html += '<div class="chip-col">';
                chunk.forEach(cls => { html += `<div class="chip ${cls}"></div>`; });
                html += '</div>';
            }
            html += '</div>';
            return html;
        }
		function setStreet(s) { game.street=s; closeModal('modal-street'); renderTable(); }
        function openStreetSelector() { document.getElementById('modal-street').classList.add('open'); }
        function addShotClock() {
            if(game.paused) return;
            const btn = document.getElementById('shot-clock-btn');
            if(!game.isShotClockActive) {
                game.shotClockTime = 30; game.isShotClockActive = true; btn.classList.add('active');
                shotClockInterval = setInterval(() => {
                    if(game.paused) return;
                    game.shotClockTime--; btn.innerText = game.shotClockTime + 's';
                    if(game.shotClockTime <= 0) { clearInterval(shotClockInterval); game.isShotClockActive = false; btn.innerText = "+30s"; btn.classList.remove('active'); }
                }, 1000);
            } else { game.shotClockTime += 30; btn.innerText = game.shotClockTime + 's'; }
        }
        // --- HELPER: Convert Card Object to String (e.g., "Ah" or "K‚ô¶") ---
// --- IMPROVED HELPER: Handle any card format (String or Object) ---
// --- HELPER: Convert Card Object to String ---
function getCardString(card) {
    if (!card) return "";
    if (typeof card === 'string') return card;
    const rank = card.rank || card.r || card.value || card.v || "?";
    const suit = card.suit || card.s || "?";
    const suitIcons = { 'h': '‚ô•', 'd': '‚ô¶', 's': '‚ô†', 'c': '‚ô£', 'H': '‚ô•', 'D': '‚ô¶', 'S': '‚ô†', 'C': '‚ô£' };
    return "" + rank + (suitIcons[suit] || suit);
}

// --- HELPER: Format Board ---
function getBoardString(boardData) {
    if (!boardData) return "";
    let str = "";
    if (Array.isArray(boardData) && Array.isArray(boardData[0])) {
        boardData.forEach((run, i) => {
            if (run.length > 0) {
                str += (boardData.length > 1 ? `[Run ${i+1}]: ` : "");
                run.forEach(c => str += getCardString(c) + " ");
                str += "  "; 
            }
        });
    } else if (Array.isArray(boardData)) {
        boardData.forEach(c => str += getCardString(c) + " ");
    }
    return str.trim();
}

// --- HELPER: SMART SHORT CODES ---
function abbreviateAction(rawText) {
    if (!rawText) return "";
    const lines = rawText.split('\n');
    let shortLines = [];

    lines.forEach(line => {
        if (line.includes("Hand Started") || line.includes("Antes") || 
            line.includes("Dealing") || line.includes("Refund:") || 
            line.includes("Winner:") || line.includes("Uncalled") || line.trim() === "") return;

        let s = line;
        s = s.replace("RAISE", "R").replace("Bet", "B")
             .replace("Call", "C").replace("Check", "X")
             .replace("Fold", "F").replace("All-in", "ALL-IN");
        s = s.replace(": ", ":"); 
        shortLines.push(s);
    });
    return shortLines.join(", ");
}

// --- HELPER: Parse Streets & CAPTURE BOARDS ---
function getStreetActions(replayData) {
    const actions = { pre: "", flop: "", turn: "", river: "" };
    if (!replayData || !Array.isArray(replayData)) return actions;

    let currentStage = 'pre'; 
    const buffers = { pre: "", flop: "", turn: "", river: "" };
    const streetBoards = { pre: "", flop: "", turn: "", river: "" };

    replayData.forEach(step => {
        const txt = step.text || "";
        if (txt.includes("Dealing Flop") || txt.includes("Flop:")) currentStage = 'flop';
        else if (txt.includes("Dealing Turn") || txt.includes("Turn:")) currentStage = 'turn';
        else if (txt.includes("Dealing River") || txt.includes("River:")) currentStage = 'river';

        if (step.board) {
            let cardCount = Array.isArray(step.board[0]) ? step.board[0].length : step.board.length;
            if (cardCount === 3 && currentStage === 'pre') currentStage = 'flop';
            else if (cardCount === 4 && (currentStage === 'pre' || currentStage === 'flop')) currentStage = 'turn';
            else if (cardCount === 5 && currentStage !== 'river') currentStage = 'river';
            
            if (currentStage !== 'pre' && !streetBoards[currentStage]) {
                streetBoards[currentStage] = getBoardString(step.board);
            }
        }
        if (txt.length > 1) buffers[currentStage] += txt + "\n";
    });

    const formatStreet = (stage) => {
        const actionText = abbreviateAction(buffers[stage]);
        const boardText = streetBoards[stage]; 
        if (boardText && actionText) return `[${boardText}]\r\n${actionText}`;
        if (boardText) return `[${boardText}]`;
        return actionText;
    };

    actions.pre = abbreviateAction(buffers.pre);
    actions.flop = formatStreet('flop');
    actions.turn = formatStreet('turn');
    actions.river = formatStreet('river');

    return actions;
}

// --- HELPER: Check VPIP ---
function checkVPIP(playerName, replayData) {
    if (!replayData || !Array.isArray(replayData)) return false;
    const moneyActions = ["Bet", "Call", "Raise", "All-in"];
    return replayData.some(step => {
        const txt = step.text || "";
        if (txt.startsWith(playerName + ":")) {
            return moneyActions.some(act => txt.includes(act));
        }
        return false;
    });
}

// --- HELPER: Fetch DB ---
function getHandFromDB(handId) {
    return new Promise((resolve) => {
        const req = indexedDB.open('PokerHistoryDB', 2); 
        req.onsuccess = (e) => {
            const db = e.target.result;
            const tx = db.transaction('hands', 'readonly');
            const store = tx.objectStore('hands');
            const query = store.get(Number(handId));
            query.onsuccess = () => resolve(query.result);
        };
        req.onerror = () => resolve(null);
    });
}

// --- MAIN EXPORT FUNCTION ---
async function exportSessionToExcel() {
    const btn = document.querySelector("button[onclick='exportSessionToExcel()']");
    const originalText = btn ? btn.innerText : "Export";
    if(btn) btn.innerText = "‚è≥ Generating Report...";

    try {
        const wb = XLSX.utils.book_new();

        // 1. FETCH DATA
        const richHistory = await Promise.all(game.history.map(async (h) => {
            const dbHand = await getHandFromDB(h.id);
            return { ...h, ...(dbHand || {}) };
        }));

        // Calculate Stats
        const calcStats = {};
        game.players.forEach(p => calcStats[p.name] = { showdownsSeen: 0, showdownsWon: 0 });
        richHistory.forEach(h => {
            if (!h.playerState) return;
            const activePlayers = h.playerState.filter(p => !p.folded && !p.sittingOut);
            if (activePlayers.length >= 2) {
                activePlayers.forEach(p => {
                    if (calcStats[p.name]) {
                        calcStats[p.name].showdownsSeen++;
                        const isWinner = h.winners && h.winners.some(w => w.name === p.name);
                        if (isWinner) calcStats[p.name].showdownsWon++;
                    }
                });
            }
        });

        // TAB 1: SUMMARY
        const sessionData = [
            ["SESSION REPORT", ""],
            ["Date", new Date().toLocaleString()],
            ["Stakes", `${game.sb} / ${game.bb} (Ante: ${game.ante})`],
            ["Total Hands", richHistory.length],
            [],
            ["FINANCIALS", ""],
            ["Total Buy-ins", game.players.reduce((sum, p) => sum + p.buyInTotal, 0)],
            ["Total Rebuys", game.players.reduce((sum, p) => sum + p.rebuyTotal, 0)],
            ["Chips in Play", game.players.reduce((sum, p) => sum + p.stack, 0)]
        ];
        XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(sessionData), "Summary");

        // TAB 2: LEADERBOARD
        const statsHeader = [
            "Player", "Net P/L", "Current Stack", "Buy-ins", "Rebuys (Count)", "Rebuys (Amt)", 
            "Hands", "VPIP %", "PFR %", "3-Bet %", "WTSD %", "WSD %", "Nit Pen", "7-2 Wins"
        ];
        const statsRows = game.players.map(p => {
            const netPL = p.stack - (p.buyInTotal + p.rebuyTotal);
            const myStats = calcStats[p.name] || { showdownsSeen: 0, showdownsWon: 0 };
            const vpip = p.totalHands > 0 ? ((p.vpipHands / p.totalHands) * 100).toFixed(1) : "0.0";
            const pfr = p.totalHands > 0 ? ((p.pfrHands / p.totalHands) * 100).toFixed(1) : "0.0";
            const threeBet = p.totalHands > 0 ? ((p.threeBetHands / p.totalHands) * 100).toFixed(1) : "0.0";
            const wtsd = p.totalHands > 0 ? ((myStats.showdownsSeen / p.totalHands) * 100).toFixed(1) : "0.0";
            const wsd = myStats.showdownsSeen > 0 ? ((myStats.showdownsWon / myStats.showdownsSeen) * 100).toFixed(1) : "0.0";

            return [
                p.name, netPL, p.stack, p.buyInTotal, p.rebuyCount || 0, p.rebuyTotal, 
                p.totalHands, vpip + "%", pfr + "%", threeBet + "%", wtsd + "%", wsd + "%", 
                p.nitCount || 0, p.sevenDeuceWins || 0
            ];
        });
        XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet([statsHeader, ...statsRows]), "Leaderboard");

        // TAB 3: ALL HANDS
        const historyHeader = [
            "#", "Winner (Pot)", "Board Cards", "Known Hole Cards", 
            "Preflop", "Flop", "Turn", "River"
        ];
        const historyRows = richHistory.map(h => {
            const winnerNames = h.winners ? h.winners.map(w => w.name).join(", ") : "No Winner";
            const res = `${winnerNames} (${h.potValue})`;

            let cardsInfo = "";
            if (h.playerState) {
                h.playerState.forEach(ps => {
                    if (ps.cards && ps.cards.length > 0) {
                        let cStr = "";
                        ps.cards.forEach(c => cStr += getCardString(c));
                        cardsInfo += `${ps.name}:${cStr}  `;
                    }
                });
            }
            const boardStr = getBoardString(h.board);
            const actions = getStreetActions(h.replayData);
            return [h.id, res, boardStr, cardsInfo, actions.pre, actions.flop, actions.turn, actions.river];
        });
        const wsHistory = XLSX.utils.aoa_to_sheet([historyHeader, ...historyRows]);
        wsHistory['!cols'] = [{wch:5}, {wch:15}, {wch:20}, {wch:35}, {wch:45}, {wch:35}, {wch:35}, {wch:35}];
        XLSX.utils.book_append_sheet(wb, wsHistory, "All Hands");

        // TABS 4+: INDIVIDUAL PLAYERS (COMPREHENSIVE STATS)
        game.players.forEach(p => {
            const netPL = p.stack - (p.buyInTotal + p.rebuyTotal);
            const myStats = calcStats[p.name] || { showdownsSeen: 0, showdownsWon: 0 };
            const vpip = p.totalHands > 0 ? ((p.vpipHands / p.totalHands) * 100).toFixed(1) : "0.0";
            const pfr = p.totalHands > 0 ? ((p.pfrHands / p.totalHands) * 100).toFixed(1) : "0.0";
            const threeBet = p.totalHands > 0 ? ((p.threeBetHands / p.totalHands) * 100).toFixed(1) : "0.0";
            const wtsd = p.totalHands > 0 ? ((myStats.showdownsSeen / p.totalHands) * 100).toFixed(1) : "0.0";
            const wsd = myStats.showdownsSeen > 0 ? ((myStats.showdownsWon / myStats.showdownsSeen) * 100).toFixed(1) : "0.0";
            
            // --- FULL STATS BLOCK ---
            const playerStatsBlock = [
                [`PLAYER REPORT: ${p.name}`],
                ["FINANCIALS", ""],
                ["Net Profit/Loss", netPL],
                ["Current Stack", p.stack],
                ["Total Buy-ins", p.buyInTotal],
                ["Rebuys (Count)", p.rebuyCount || 0],
                ["Rebuys (Amount)", p.rebuyTotal],
                [],
                ["PLAY STYLE", ""],
                ["Total Hands", p.totalHands],
                ["VPIP", `${vpip}%`],
                ["PFR", `${pfr}%`],
                ["3-Bet", `${threeBet}%`],
                [],
                ["SHOWDOWN", ""],
                ["Went to Showdown (WTSD)", `${wtsd}%`],
                ["Won at Showdown (WSD)", `${wsd}%`],
                [],
                ["EXTRAS", ""],
                ["Nit Penalties", p.nitCount || 0],
                ["7-2 Wins", p.sevenDeuceWins || 0],
                [],
                ["HAND HISTORY", ""],
                ["#", "Result", "Pot", "My Cards", "Board & Villains"]
            ];

            const pRows = [];
            richHistory.forEach(h => {
                let pState = null;
                if (h.playerState) pState = h.playerState.find(ps => ps.name === p.name);
                
                if (pState && !pState.sittingOut) {
                    const isWinner = h.winners && h.winners.some(w => w.name === p.name);
                    const playedHand = !pState.folded;
                    const hasVPIP = checkVPIP(p.name, h.replayData);
                    
                    if (isWinner || playedHand || hasVPIP) {
                        const resultStr = isWinner ? "WON" : (pState.folded ? "Folded" : "Lost");
                        
                        let myCards = "";
                        if (pState.cards) pState.cards.forEach(c => myCards += getCardString(c));

                        let villainsStr = "";
                        if (h.playerState) {
                            h.playerState.forEach(vs => {
                                if (vs.name !== p.name && vs.cards && vs.cards.length > 0) {
                                    let vCards = "";
                                    vs.cards.forEach(c => vCards += getCardString(c));
                                    villainsStr += `${vs.name}(${vCards}) `;
                                }
                            });
                        }
                        const context = `${getBoardString(h.board)} | Vs: ${villainsStr}`;
                        pRows.push([h.id, resultStr,h.potValue || 0, myCards, context]);
                    }
                }
            });

            if(pRows.length > 0) {
                const finalData = [...playerStatsBlock, ...pRows];
                const safeName = p.name.replace(/[\\/?*\[\]]/g, "").substring(0, 30);
                const ws = XLSX.utils.aoa_to_sheet(finalData);
                ws['!cols'] = [{wch:5}, {wch:10}, {wch:10}, {wch:50}];
                XLSX.utils.book_append_sheet(wb, ws, safeName);
            }
        });

        const fileName = `PokerSession_${new Date().toISOString().slice(0,10)}.xlsx`;
        XLSX.writeFile(wb, fileName);

    } catch (err) {
        console.error(err);
        alert("Error: " + err.message);
    } finally {
        if(btn) btn.innerText = originalText;
    }
}

function saveSessionFile() {
            // Saves the entire game state (History, Players, Settings)
            const backup = {
                timestamp: new Date().toISOString(),
                version: "45.2",
                history: game.history,
                players: game.players, // Current stack sizes
                settings: { sb: game.sb, bb: game.bb, ante: game.ante, nit: game.nitSettings }
            };
            
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(backup));
            const a = document.createElement('a');
            a.href = dataStr;
            a.download = `Poker_Backup_${new Date().toISOString().slice(0,10)}.json`;
            a.click();
        }
		function triggerLoadSession() {
    const input = document.getElementById('file-input-session');
    if (input) {
        // FIX: Force the input to accept ANY file type. 
        // This solves the issue where mobile phones grey out .json files.
        input.accept = '*/*'; 
        input.click();
    } else {
        alert("Error: File input element not found. Please reload.");
    }
}

function loadSessionFile(input) {
    const file = input.files[0];
    if(!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = JSON.parse(e.target.result);
            
            // Basic validation to ensure it's a real poker file
            if(!data.history || !Array.isArray(data.history)) {
                alert("Error: Invalid Game File Format"); 
                return;
            }
            
            if(confirm(`Load session from ${data.timestamp || 'Unknown Date'}?\n(This will overwrite the current game)`)) {
                // 1. Restore History
                game.history = data.history;
                
                // 2. Restore Players (Stacks, Names, etc.)
                if(data.players) game.players = data.players;
                
                // 3. Restore Settings
                if(data.settings) {
                    game.sb = data.settings.sb;
                    game.bb = data.settings.bb; 
                    game.nitSettings = data.settings.nit || game.nitSettings;
                }
                
                // 4. Force a Pot Recalculation just in case
                game.pot = recalculateGlobalPot();

                // 5. Refresh UI
                openMenuModal(); // Go to menu so you can see the loaded history
                renderTable();   // Update the visual table
                alert("Session Loaded Successfully!");
            }
        } catch(err) {
            alert("Error reading file: " + err);
        }
    };
    reader.readAsText(file);
    input.value = ''; // Reset input so you can load the same file again if needed
}
		function setHistoryPlayerFilter(val) {
            game.historyPlayerFilter = val;
            renderHistoryList();
		}
		
		function saveBigPotThreshold() {
            const val = parseFloat(document.getElementById('big-pot-input').value);
            if(val > 0) {
                game.bigPotThreshold = val;
                alert(`Big Pots defined as > ${formatMoney(val)}`);
                renderHistoryList();
            }
        }
		// --- 7-2 GAME LOGIC ---
        function trigger72Game() {
            if(game.contextPlayerIdx === -1) return;
            const winnerIdx = game.contextPlayerIdx;
            const p = game.players[winnerIdx];
            
            const bounty = parseFloat(prompt(`Amount for 7-2 Game (Everyone pays ${p.name}):`, game.sevenDeuceAmt));
            if(isNaN(bounty) || bounty <= 0) return;
            game.sevenDeuceAmt = bounty;

            let totalCollected = 0;
            game.players.forEach((opp, i) => {
                if(i !== winnerIdx && !opp.sittingOut && opp.stack > 0) {
                    let payAmt = Math.min(opp.stack, bounty);
                    opp.stack -= payAmt;
                    totalCollected += payAmt;
                }
            });

            p.stack += totalCollected;
            p.sevenDeuceWins++;
            
            game.history.unshift({
                id: "7-2", 
                time: new Date().toLocaleTimeString(),
                tags: ['7-2 Game'],
                winner: `${p.name} (+${formatMoney(totalCollected)})`,
                pot: formatMoney(totalCollected),
                board: [],
                replayData: [],
                playerState: JSON.parse(JSON.stringify(game.players)),
                favorite: true 
            });

            hideContextMenu();
            alert(`${p.name} collects ${formatMoney(totalCollected)} for the 7-2 Game!`);
            renderTable();
        }

        // --- BOMB POT LOGIC ---
        function openBombSettings() {
            const list = document.getElementById('bomb-player-list');
            list.innerHTML = "";
            game.players.forEach((p, i) => {
                if(!p.sittingOut) {
                    const checked = p.isOnBreak ? "" : "checked"; 
                    list.innerHTML += `
                        <div style="background:#333; padding:5px; border-radius:4px; display:flex; align-items:center; gap:5px;">
                            <input type="checkbox" id="bomb-p-${i}" ${checked}>
                            <label for="bomb-p-${i}" style="color:white; margin:0;">${p.name}</label>
                        </div>
                    `;
                }
            });
            closeModal('modal-menu');
            document.getElementById('modal-bomb-settings').classList.add('open');
        }

        function startBombPot() {
            const ante = parseFloat(document.getElementById('bomb-ante').value);
            if(isNaN(ante)) return alert("Invalid Ante");

            // 1. SET GAME MODES
            game.isBombPot = true;
            game.gameMode = 'plo'; 
            game.boards = [[], []]; 
            game.runoutCount = 2;   
            game.pot = 0;
            
            let activeCount = 0;
            game.players.forEach((p, i) => {
                const cb = document.getElementById(`bomb-p-${i}`);
                
                // IMPORTANT: Reset Side Pot Tracker for everyone first
                p.handTotalBet = 0; 
                p.currentBet = 0; 
                p.hasActed = false;

                if(cb && cb.checked && p.stack > 0) {
                    p.folded = false; p.isOnBreak = false; p.sittingOut = false;
                    const pay = Math.min(p.stack, ante);
                    
                    // FIX: Precision Math
                    p.stack = parseFloat((p.stack - pay).toFixed(2)); 
                    game.pot = parseFloat((game.pot + pay).toFixed(2));
                    
                    // Track contribution for side pots
                    p.handTotalBet = pay; 
                    
                    // IMPORTANT: Empty cards so user MUST fill them
                    p.cards = []; 
                    
                    activeCount++;
                } else {
                    p.folded = true; p.cards = [];
                }
            });

            if(activeCount < 2) return alert("Need at least 2 players");

            // 2. MOVE DEALER & JUMP TO FLOP
            game.dealerIndex = getNextActive(game.dealerIndex + 1); 
            game.street = 1; // Flop
            game.activePlayerIndex = getNextActive(game.dealerIndex + 1); 
            
            closeModal('modal-bomb-settings');
            saveReplayStep(`üí£ Double Board PLO Bomb Pot Started (Pot: ${formatMoney(game.pot)})`);
            renderTable();
            document.getElementById('street-name').innerText = "FLOP (BOMB)";
            alert("üí£ BOMB POT STARTED!\n\n1. Tap 'CARDS' to enter 4 cards for each player.\n2. Tap Board Area to enter 5 cards for BOTH boards.");
        }

        // --- PLO EVALUATOR (2 Hole + 3 Board) ---
        function getPLOHighHand(hole, board) {
            if(hole.length < 4 || board.length < 3) return { rank: 0, name: "Invalid" }; 
            
            // Helper to get combinations
            const getCombos = (arr, k) => {
                let i, j, combs, head, tailcombs;
                if (k > arr.length || k <= 0) return [];
                if (k == arr.length) return [arr];
                if (k == 1) { combs = []; for (i = 0; i < arr.length; i++) combs.push([arr[i]]); return combs; }
                combs = [];
                for (i = 0; i < arr.length - k + 1; i++) {
                    head = arr.slice(i, i + 1);
                    tailcombs = getCombos(arr.slice(i + 1), k - 1);
                    for (j = 0; j < tailcombs.length; j++) combs.push(head.concat(tailcombs[j]));
                }
                return combs;
            };

            const holeCombos = getCombos(hole, 2);
            const boardCombos = getCombos(board, 3);
            let bestScore = { rank: -1, kickers: [] };

            holeCombos.forEach(h2 => {
                boardCombos.forEach(b3 => {
                    const fiveCard = [...h2, ...b3];
                    const score = getHandStrength(fiveCard); 
                    if(compareScores(score, bestScore) > 0) bestScore = score;
                });
            });
            return bestScore;
        }
		// --- SEAT SWAP LOGIC ---
let swapSourceIndex = -1;

function updateAdvancedStats(winners) {
    // 1. Check if it was actually a Showdown (Fix for the WSD Bug)
    // A showdown only happens if MORE THAN 1 player is not folded.
    const activePlayers = game.players.filter(p => !p.folded);
    const isRealShowdown = activePlayers.length > 1;

    game.players.forEach(p => {
        // Initialize stats object if missing
        if (!p.stats) {
            p.stats = { 
                handsSeenFlop: 0, 
                showdownsSeen: 0, 
                showdownsWon: 0,
                wsdPercent: 0,  
                wtsdPercent: 0,
                vpipHands: 0, pfrHands: 0, threeBetHands: 0 
            };
        }

        // A. Saw Flop Logic
        const sawFlop = !p.folded || (p.folded && p.foldedStreet >= 1);
        if (sawFlop) {
            p.stats.handsSeenFlop++;
        }

        // B. Showdown Logic (Fixed)
        // You only get credit for "Going to Showdown" if:
        // 1. You didn't fold
        // 2. There was actually a showdown (someone else didn't fold too)
        if (!p.folded && isRealShowdown) {
            p.stats.showdownsSeen++;

            // Check if this player is in the winners list
            const isWinner = winners.some(w => 
                (w.idx !== undefined && w.idx === game.players.indexOf(p)) || 
                (w.name === p.name)
            );

            if (isWinner) {
                p.stats.showdownsWon++;
            }
        }

        // C. Update Percentages
        if (p.stats.showdownsSeen > 0) {
            p.stats.wsdPercent = ((p.stats.showdownsWon / p.stats.showdownsSeen) * 100).toFixed(0);
        } else {
            p.stats.wsdPercent = 0;
        }

        if (p.stats.handsSeenFlop > 0) {
            p.stats.wtsdPercent = ((p.stats.showdownsSeen / p.stats.handsSeenFlop) * 100).toFixed(0);
        } else {
            p.stats.wtsdPercent = 0;
        }
    });
}

// --- CASUAL MODE LOGIC ---

// 1. Handle Setup Screen Toggle
let setupCasualActive = true; // Default to ON
function toggleSetupCasual() {
    setupCasualActive = !setupCasualActive;
    
    // 1. Visual Toggle
    const sw = document.getElementById('sw-casual-setup');
    if(setupCasualActive) sw.classList.add('on'); else sw.classList.remove('on');
    
    // 2. Text Update Logic
    const title = document.getElementById('setup-mode-title');
    const desc = document.getElementById('setup-mode-desc');
    
    if(setupCasualActive) {
        title.innerText = "Casual Mode";
        title.style.color = "var(--accent-green)";
        desc.innerText = "Infinite stacks. Track bets & scores only.";
    } else {
        title.innerText = "Bookkeeper Mode";
        title.style.color = "var(--accent-blue)";
        desc.innerText = "Strict accounting. Chips are limited.";
    }
}

// 2. Handle In-Game Toggle
function toggleCasualMode() {
    game.lazyMode = !game.lazyMode;
    
    // Update visual state immediately
    const btn = document.getElementById('btn-casual-mode');
    if(btn) {
        btn.innerText = game.lazyMode ? "CASUAL: ON" : "CASUAL: OFF";
        btn.style.background = game.lazyMode ? "var(--accent-gold)" : "#555";
        btn.style.color = game.lazyMode ? "black" : "white";
    }
    
    // Update the background table (hide/show stacks)
    renderTable(); 
    saveLocal();
}
// 3. Update 'startGame' to read the setup value
// (Find your existing startGame function and add this line near the top of it)
/* function startGame() {
       game.lazyMode = setupCasualActive; 
   }
*/

// 4. Update 'openMenuModal' to show correct status
// (Find the end of openMenuModal where we set button colors, and add this)
/*
   // ... inside openMenuModal ...
   const btnCasual = document.getElementById('btn-casual-mode');
   if(btnCasual) {
       btnCasual.innerText = game.lazyMode ? "CASUAL: ON" : "CASUAL: OFF";
       btnCasual.style.background = game.lazyMode ? "var(--accent-gold)" : "#555";
       btnCasual.style.color = game.lazyMode ? "black" : "white";
   }
*/

function toggleSwapSelect(idx) {
    if (swapSourceIndex === -1) {
        // Select First Player
        swapSourceIndex = idx;
        openMenuModal(); // Re-render to show selection (yellow button)
    } else if (swapSourceIndex === idx) {
        // Deselect if clicked again
        swapSourceIndex = -1;
        openMenuModal();
    } else {
        // Target Selected -> Perform Swap
        performSeatSwap(swapSourceIndex, idx);
        swapSourceIndex = -1;
        openMenuModal(); // Refresh menu
        renderTable();   // Update main table
    }
}

function performSeatSwap(i1, i2) {
    // 1. Swap the Player Objects in the Array
    const temp = game.players[i1];
    game.players[i1] = game.players[i2];
    game.players[i2] = temp;

    // 2. Helper to map old index to new index
    const mapIndex = (oldI) => {
        if (oldI === i1) return i2;
        if (oldI === i2) return i1;
        return oldI;
    };

    // 3. Update Pointers (So Dealer/Turn follows the player)
    game.dealerIndex = mapIndex(game.dealerIndex);
    game.activePlayerIndex = mapIndex(game.activePlayerIndex);
    game.currentSBIndex = mapIndex(game.currentSBIndex);
    game.currentBBIndex = mapIndex(game.currentBBIndex);
    game.manualSBIndex = mapIndex(game.manualSBIndex);
    game.manualBBIndex = mapIndex(game.manualBBIndex);
    
    // 4. Update Context Menu Pointer if open
    if(game.contextPlayerIdx === i1) game.contextPlayerIdx = i2;
    else if(game.contextPlayerIdx === i2) game.contextPlayerIdx = i1;

    // 5. Log it
    saveReplayStep(`Seat Change: ${game.players[i2].name} ‚áÑ ${game.players[i1].name}`);
}

function setMuckedHand() {
    // 1. Create two Mystery Cards
    const mystery = {rank:'?', suit:'s'}; // Suit is ignored for '?'
    game.tempCards = [mystery, mystery];
    
    // 2. Refresh the preview so you see [?][?]
    updateCardPrev(); 
    
    // 3. Save automatically (optional, or you can click Save manually)
    saveCardSelection();
}

function handleSmartAllIn() {
    const val = parseFloat(game.tempBet);
    
    if(isNaN(val) || val <= 0) {
        alert("Please enter the All-In amount first.");
        return;
    }

    const p = game.players[game.activePlayerIndex];

    // 1. IF CASUAL MODE IS OFF (Normal Logic)
    if (!game.lazyMode) {
        if(val > p.stack) { alert("Not enough chips for that amount!"); return; }
        game.tempBet = val.toString();
        confirmBet(); 
        return;
    }

    // 2. IF CASUAL MODE IS ON (Smart Logic)
    // We assume 'val' is the TRUE amount of chips they physically have right now.
    
    const oldStack = p.stack;
    const newStack = val;
    const diff = oldStack - newStack; // e.g. 100 - 5 = 95
    
    // A. Fix the Present: Force stack to match input
    p.stack = newStack;
    
    // CRITICAL ENGINE FIX: 
    // Use a hidden correction field so we don't mess up the "Initial Buy-in" stat.
    p.casualCorrection = (p.casualCorrection || 0) - diff;

    // B. Fix the Past: Calculate original starting stack for the Replay
    let previousBetsInHand = p.handTotalBet || 0; 
    let actualStartStack = previousBetsInHand + newStack;
    
    // Update the Snapshot so if we restart the hand, it uses the correct amount
    if(game.handStartSnapshot) {
        const snapshotPlayer = game.handStartSnapshot.find(sp => sp.name === p.name);
        if(snapshotPlayer) {
            snapshotPlayer.stack = actualStartStack;
            // Also fix buyin in snapshot
            snapshotPlayer.buyInTotal = (snapshotPlayer.buyInTotal || 0) - diff;
        }
    }

    // Update the Replay Log Visuals immediately
    if(game.currentHandReplay && game.currentHandReplay.length > 0) {
        const startLog = game.currentHandReplay[0];
        if(startLog && startLog.players) {
            const replayP = startLog.players.find(rp => rp.name === p.name);
            if(replayP) replayP.stack = actualStartStack;
        }
    }

    // Force Recalculate pot NOW to ensure no ghosts exist before the bet
    game.pot = recalculateGlobalPot();

    // C. Perform the All-In Action
    pushUndoState();
    stopTurnTimer();
    
    // This function handles the betting logic (creating side pots, etc.)
    placeBetLogic(game.activePlayerIndex, newStack);
    
    p.lastAction = `ALL IN (${formatMoney(p.currentBet)})`;
    
    // Update Stats
    if(game.street === 0) {
        if(!p.hasPFRThisHand) { p.pfrHands++; p.hasPFRThisHand = true; }
    } else {
        p.postFlopAggressiveActions++; p.postFlopOpportunities++;
    }

    saveReplayStep(`${p.name}: ALL IN (${formatMoney(newStack)}) [Stack Corrected]`);
    closeModal('modal-bet');
    advanceTurn();
}

// --- END GAME / SETTLEMENT LOGIC ---

// --- END GAME / SETTLEMENT LOGIC (FIXED & EDITABLE) ---

// --- END GAME / SETTLEMENT LOGIC (V2: FULLY EDITABLE) ---

function openSettlementModal() {
    const modal = document.getElementById('settlement-modal');
    const tbody = document.getElementById('settlement-table-body');
    tbody.innerHTML = ""; 

    game.players.forEach((p, index) => {
        // DIRECT MAPPING: No math here, just grabbing values.
        const initial = parseFloat(p.buyInTotal) || 0; 
        const rebuyAmt = parseFloat(p.rebuyTotal) || 0;
        const rebuyCnt = parseInt(p.rebuyCount) || 0;
        const stack = parseFloat(p.stack) || 0;
        
        // Math for display only
        const totalInvested = initial + rebuyAmt;
        const net = stack - totalInvested;
        const color = net >= 0 ? '#4CAF50' : '#F44336';
        const sign = net >= 0 ? '+' : '';

        const tr = document.createElement('tr');
        tr.style.borderBottom = '1px solid #333';
        
        tr.innerHTML = `
            <td style="padding:8px; font-weight:bold;">${p.name}</td>
            
            <td style="padding:8px;">
                <input type="number" id="set-in-${index}" value="${initial}" 
                 style="width:70px; background:#222; border:1px solid #555; color:#fff; padding:4px; border-radius:4px;"
                 oninput="updateSettlementLine(${index})">
            </td>

            <td style="padding:8px;">
                <input type="number" id="set-rc-${index}" value="${rebuyCnt}" 
                 style="width:50px; background:#222; border:1px solid #555; color:#aaa; padding:4px; border-radius:4px;"
                 oninput="updateSettlementLine(${index})">
            </td>

            <td style="padding:8px;">
                <input type="number" id="set-ra-${index}" value="${rebuyAmt}" 
                 style="width:70px; background:#222; border:1px solid #555; color:#fff; padding:4px; border-radius:4px;"
                 oninput="updateSettlementLine(${index})">
            </td>

            <td style="padding:8px; color:#aaa;" id="set-tot-${index}">
                ${totalInvested.toFixed(2)}
            </td>

            <td style="padding:8px;">
                <input type="number" id="set-stack-${index}" value="${stack}" 
                 style="width:70px; background:#222; border:1px solid #555; color:#fff; padding:4px; border-radius:4px;"
                 oninput="updateSettlementLine(${index})">
            </td>

            <td style="padding:8px; font-weight:bold; color:${color};" id="set-pl-${index}">
                ${sign}${net.toFixed(2)}
            </td>
        `;
        tbody.appendChild(tr);
    });

    calculateSettlementTotals();
    modal.classList.add('active');
}

// Ensure the update function keeps them separate
function updateSettlementLine(index) {
    const initVal = parseFloat(document.getElementById(`set-in-${index}`).value) || 0;
    const rcVal = parseInt(document.getElementById(`set-rc-${index}`).value) || 0;
    const raVal = parseFloat(document.getElementById(`set-ra-${index}`).value) || 0;
    const stackVal = parseFloat(document.getElementById(`set-stack-${index}`).value) || 0;

    // UPDATE DATA
    game.players[index].buyInTotal = initVal; // Explicitly set Initial
    game.players[index].rebuyCount = rcVal;   // Explicitly set Rebuy Count
    game.players[index].rebuyTotal = raVal;   // Explicitly set Rebuy Amt
    game.players[index].stack = stackVal;     // Explicitly set Stack

    // UPDATE DISPLAY
    const totalInv = initVal + raVal;
    const net = stackVal - totalInv;

    document.getElementById(`set-tot-${index}`).innerText = totalInv.toFixed(2);
    
    const plCell = document.getElementById(`set-pl-${index}`);
    plCell.innerText = (net >= 0 ? '+' : '') + net.toFixed(2);
    plCell.style.color = net >= 0 ? '#4CAF50' : '#F44336';

    calculateSettlementTotals();
}
function calculateSettlementTotals() {
    let sumInit = 0, sumRc = 0, sumRa = 0, sumTotIn = 0, sumStack = 0, sumPl = 0;

    game.players.forEach(p => {
        const i = parseFloat(p.buyInTotal) || 0;
        const rc = parseInt(p.rebuyCount) || 0;
        const ra = parseFloat(p.rebuyTotal) || 0;
        const s = parseFloat(p.stack) || 0;
        
        sumInit += i;
        sumRc += rc;
        sumRa += ra;
        sumTotIn += (i + ra);
        sumStack += s;
        sumPl += (s - (i + ra));
    });

    // Update Footer Cells
    document.getElementById('ft-initial').innerText = sumInit.toFixed(2);
    document.getElementById('ft-rebuy-count').innerText = sumRc;
    document.getElementById('ft-rebuy-amt').innerText = sumRa.toFixed(2);
    document.getElementById('ft-total-in').innerText = sumTotIn.toFixed(2);
    document.getElementById('ft-stack').innerText = sumStack.toFixed(2);
    document.getElementById('ft-pl').innerText = (sumPl >= 0 ? '+' : '') + sumPl.toFixed(2);

    // Bank Check
    const diff = sumStack - sumTotIn;
    const statusBox = document.getElementById('bank-status');
    // Allow small floating point margin (0.05)
    if (Math.abs(diff) < 0.05) {
        statusBox.innerHTML = "‚úÖ BANK BALANCED (Perfect Match)";
        statusBox.style.color = "#4CAF50"; 
        statusBox.style.border = "1px solid #4CAF50";
    } else {
        const msg = diff > 0 ? `Extra Money: +${diff.toFixed(2)}` : `Missing Money: ${diff.toFixed(2)}`;
        statusBox.innerHTML = `‚ö†Ô∏è BANK MISMATCH: ${msg}`;
        statusBox.style.color = "#FF9800"; 
        statusBox.style.border = "1px solid #FF9800";
    }
}

function closeSettlement() {
    document.getElementById('settlement-modal').classList.remove('active');
}

// --- WIRELESS TV SYNC (PEERJS) ---

// Global Sync Variables
let peer = null;
let conn = null;
let myPeerId = null;
const APP_PREFIX = "ultimatedealer-v1-"; 

// 1. Initialize PeerJS & TV Stage
function initWirelessSync() {
    // A. Inject Join Controls
    const setupDiv = document.querySelector('.setup-container');
    if (setupDiv && !document.getElementById('wireless-controls')) {
        const joinDiv = document.createElement('div');
        joinDiv.id = 'wireless-controls';
        joinDiv.style.marginTop = "20px";
        joinDiv.style.padding = "15px";
        joinDiv.style.background = "#222";
        joinDiv.style.border = "1px solid #444";
        joinDiv.style.borderRadius = "8px";
        joinDiv.innerHTML = `
            <h3 style="margin-top:0; color:var(--accent-blue);">üì∫ TV / Remote Display</h3>
            <div id="host-ui-area">
                <div style="font-size:12px; color:#888;">YOUR HOST ID:</div>
                <div id="my-host-id" style="font-size:24px; font-weight:bold; color:var(--accent-green); letter-spacing:2px;">Loading...</div>
            </div>
            <div id="join-ui-area" style="margin-top:15px; border-top:1px solid #444; padding-top:15px;">
                <label>Join Existing Game (TV Mode)</label>
                <div style="display:flex; gap:5px;">
                    <input type="text" id="remote-id-input" placeholder="Enter Host ID" style="text-transform:uppercase;">
                    <button class="btn" style="background:var(--accent-blue); width:auto;" onclick="joinGame()">JOIN</button>
                </div>
            </div>
        `;
        setupDiv.appendChild(joinDiv);
    }

    // B. Inject TV Stage (The Oval Table Screen)
    if (!document.getElementById('tv-stage')) {
        const tvDiv = document.createElement('div');
        tvDiv.id = 'tv-stage';
        tvDiv.style.display = 'none'; // Hidden by default
        tvDiv.style.position = 'fixed';
        tvDiv.style.top = '0';
        tvDiv.style.left = '0';
        tvDiv.style.width = '100vw';
        tvDiv.style.height = '100vh';
        tvDiv.style.background = '#121212';
        tvDiv.style.zIndex = '9999';
        
        tvDiv.innerHTML = `
            <div class="replay-container" style="height:100%; margin:0; padding-top:0;">
                <div class="replay-table-bg" style="width:90%; height:80%; border:8px solid #27ae60;">
                    <div id="tv-board" style="display:flex; gap:5px; justify-content:center; margin-bottom:20px; transform:scale(1.5);"></div>
                    <div id="tv-pot-visual" style="position:absolute; top:40%; left:50%; transform:translate(-50%, -50%);"></div>
                </div>
            </div>
            <div id="tv-message-area" style="position:absolute; top:20%; width:100%; text-align:center; font-size:40px; color:gold; font-weight:bold; text-shadow:0 2px 4px black; pointer-events:none;"></div>
        `;
        document.body.appendChild(tvDiv);
    }

    // C. Start PeerJS
    const randomId = Math.floor(1000 + Math.random() * 9000);
    const peerId = APP_PREFIX + randomId;
    peer = new Peer(peerId);

    peer.on('open', (id) => {
        myPeerId = id.replace(APP_PREFIX, ''); 
        const display = document.getElementById('my-host-id');
        if(display) display.innerText = myPeerId;
        console.log('My peer ID is: ' + id);
    });

    peer.on('connection', (connection) => {
        console.log("Incoming connection...");
        if(!conn) { // Only accept if we are the Host
            conn = connection; // Store connection (though we broadcast to all usually)
            setupConnectionEvents(connection);
            setTimeout(() => sendData(), 500);
        }
    });
}

// 2. Logic for the TV (Viewer)
function joinGame() {
    const input = document.getElementById('remote-id-input').value;
    if(!input) return alert("Please enter Host ID");
    
    const hostPeerId = APP_PREFIX + input;
    console.log("Connecting to " + hostPeerId);
    
    conn = peer.connect(hostPeerId);
    
    // IMPORTANT: Enable "Player Mode" CSS
    document.body.classList.add('player-view-mode');
    
    setupConnectionEvents(conn);
}

// 3. Connection Events
function setupConnectionEvents(connection) {
    connection.on('open', () => {
        console.log("Connected!");
        if(document.body.classList.contains('player-view-mode')) {
             // We are the TV, waiting for data...
        }
    });

    connection.on('data', (data) => {
        if (data && data.players) {
            game = data;
            
            // DECIDE WHICH VIEW TO RENDER
            if (document.body.classList.contains('player-view-mode')) {
                 renderTVView(); // Use the Oval Table
            } else {
                 renderTable(); // Use the Grid (Dealer)
            }
        }
    });
}

// 4. Send Data (Dealer Only)
const originalSaveLocal = saveLocal;
saveLocal = function() {
    originalSaveLocal(); // Save to phone memory
    
    // LOOP FIX: Only send data if we are the HOST (we have connections) 
    // AND we are not a client (we didn't join someone else)
    if (peer && peer.connections && Object.keys(peer.connections).length > 0 && !document.body.classList.contains('player-view-mode')) {
        sendData();
    }
};

function sendData() {
    // Broadcast to ALL connected TVs
    if (peer && peer.connections) {
        const payload = JSON.parse(JSON.stringify(game));
        // Pre-render HTML for consistency
        payload.potDisplayHtml = document.getElementById('pot-amount').innerHTML;
        
        for (const connId in peer.connections) {
            peer.connections[connId].forEach(c => c.send(payload));
        }
    }
}

// 5. The New TV Renderer (Oval Table)
function renderTVView() {
    // Show TV Stage, Hide everything else
    document.getElementById('tv-stage').style.display = 'flex';
    document.getElementById('view-game').style.display = 'none'; 
    document.getElementById('view-setup').style.display = 'none';

    const container = document.querySelector('#tv-stage .replay-table-bg');
    
    // Clear old players
    const existingPlayers = container.querySelectorAll('.replay-player');
    existingPlayers.forEach(p => p.remove());

    // Update Board
    const tvBoard = document.getElementById('tv-board');
    tvBoard.innerHTML = "";
    if (game.boards && game.boards[0]) {
        game.boards[0].forEach(c => {
            tvBoard.innerHTML += createCardHTML(c).replace('card-visual', 'card-visual'); 
        });
    }

    // Update Pot
    const potDiv = document.getElementById('tv-pot-visual');
    let potHtml = `<div style="font-size:30px; color:#2ecc71; font-weight:bold; background:rgba(0,0,0,0.7); padding:10px 20px; border-radius:20px; border:2px solid #2ecc71;">‚Ç¨${formatMoney(game.pot)}</div>`;
    // Glow effect if pot is big (> 50)
    if(game.pot > 50) potDiv.style.boxShadow = "0 0 30px #2ecc71";
    potDiv.innerHTML = potHtml;

    // Render Players in Circle
    const players = game.players;
    const totalPlayers = players.length;
    
    players.forEach((p, i) => {
        if(p.sittingOut) return; 

        const el = document.createElement('div');
        el.className = `replay-player ${p.folded ? 'folded' : ''}`;
        
        // Math to place in circle
        const angle = (i / totalPlayers) * 2 * Math.PI + (Math.PI / 2);
        const radius = 42; 
        const xPos = 50 + radius * Math.cos(angle);
        const yPos = 50 + radius * Math.sin(angle);
        
        el.style.left = xPos + "%";
        el.style.top = yPos + "%";
        el.style.transform = "translate(-50%, -50%) scale(1.3)"; 
        
        // Active Player Glow
        if (i === game.activePlayerIndex) el.style.boxShadow = "0 0 30px gold";
        // Winner Glow (checks history for most recent winner)
        if (game.history && game.history[0] && game.history[0].winners.find(w => w.name === p.name)) {
             el.style.boxShadow = "0 0 30px #2ecc71";
             el.style.borderColor = "#2ecc71";
        }

        // Cards Logic (Hidden vs Showdown)
        let cardsHtml = "";
        if (!p.folded) {
            if (game.street === 4 && p.cards.length) {
                 p.cards.forEach(c => cardsHtml += createCardHTML(c));
            } else {
                 cardsHtml = `<div class="card-visual back small"></div><div class="card-visual back small"></div>`;
            }
        }

        const isDealer = (i === game.dealerIndex);
        
        el.innerHTML = `
            ${isDealer ? '<div class="dealer-btn-large" style="top:-15px; right:-15px;">D</div>' : ''}
            <div style="background:#222; border:2px solid #444; border-radius:8px; padding:5px; min-width:80px; text-align:center; ${i === game.activePlayerIndex ? 'border-color:gold;' : ''}">
                <div style="font-weight:bold; color:white; font-size:12px;">${p.name}</div>
                <div style="color:#2ecc71; font-weight:bold; font-size:14px;">‚Ç¨${formatMoney(p.stack)}</div>
            </div>
            <div style="display:flex; justify-content:center; margin-top:-10px;">${cardsHtml}</div>
            ${p.currentBet > 0 ? `<div style="background:gold; color:black; border-radius:10px; padding:2px 8px; font-weight:bold; font-size:12px; position:absolute; bottom:-12px; left:50%; transform:translateX(-50%); white-space:nowrap;">‚Ç¨${formatMoney(p.currentBet)}</div>` : ''}
        `;
        
        container.appendChild(el);
    });
    
    // Message Overlay (e.g. "Nit!")
    const msgArea = document.getElementById('tv-message-area');
    if(document.getElementById('nit-overlay').classList.contains('visible')) {
         msgArea.innerHTML = document.getElementById('nit-loser-msg').innerHTML;
    } else {
         msgArea.innerHTML = "";
    }
}

// Initialize
document.addEventListener('DOMContentLoaded', initWirelessSync);
    </script>
	<div id="settlement-modal" class="modal-overlay">
    <div class="modal-content" style="max-width: 1000px; width: 95%;">
        <div class="modal-header">
            <h2>üèÅ Session Settlement</h2>
            <button class="close-btn" onclick="closeSettlement()">√ó</button>
        </div>
        
        <div class="modal-body">
            <p style="color:#aaa; font-size:14px; margin-bottom:15px;">
                Adjust Initial Buy-ins, Rebuys, and Final Stacks. Totals update automatically.
            </p>

            <div style="overflow-x:auto;">
                <table style="width:100%; border-collapse: collapse; color:#fff; font-size:13px;">
                    <thead>
                        <tr style="border-bottom: 1px solid #444; text-align:left; color:#888;">
                            <th style="padding:8px;">Player</th>
                            <th style="padding:8px;">Initial Buy-in</th>
                            <th style="padding:8px;">Rebuys (#)</th>
                            <th style="padding:8px;">Rebuys ($)</th>
                            <th style="padding:8px;">Total In</th>
                            <th style="padding:8px;">Final Stack</th>
                            <th style="padding:8px;">Net P/L</th>
                        </tr>
                    </thead>
                    <tbody id="settlement-table-body">
                        </tbody>
                    <tfoot>
                        <tr style="background:#222; font-weight:bold; border-top:1px solid #555;">
                            <td style="padding:10px;">TOTALS</td>
                            <td style="padding:10px;" id="ft-initial">0</td>
                            <td style="padding:10px;" id="ft-rebuy-count">0</td>
                            <td style="padding:10px;" id="ft-rebuy-amt">0</td>
                            <td style="padding:10px; color:#aaa;" id="ft-total-in">0</td>
                            <td style="padding:10px;" id="ft-stack">0</td>
                            <td style="padding:10px;" id="ft-pl">0</td>
                        </tr>
                    </tfoot>
                </table>
            </div>

            <div id="bank-status" style="margin-top:15px; padding:10px; background:#333; border-radius:5px; text-align:center; font-weight:bold;">
                Checking Bank...
            </div>

            <hr style="border:0; border-top:1px solid #444; margin: 20px 0;">

            <div style="display:flex; gap:10px; flex-wrap:wrap;">
                <button class="btn" style="flex:1; background:#4CAF50;" onclick="exportSessionToExcel()">
                    üìä Export Excel
                </button>
                <button class="btn" style="flex:1; background:#2196F3;" onclick="saveSessionFile()">
                    üíæ Save JSON
                </button>
            </div>
            
            <button class="btn" style="width:100%; margin-top:10px; background:#444;" onclick="closeSettlement()">
                Return to Game
            </button>
        </div>
    </div>
</div>
</body>
</html>